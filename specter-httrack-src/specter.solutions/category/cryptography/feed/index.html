<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Cryptography &#8211; Specter Solutions | Your Keys, Your Bitcoin</title>
	<atom:link href="https://specter.solutions/category/cryptography/feed/" rel="self" type="application/rss+xml" />
	<link>https://specter.solutions</link>
	<description></description>
	<lastBuildDate>Tue, 19 Oct 2021 09:55:16 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.4.2</generator>

<image>
	<url>https://specter.solutions/wp-content/uploads/2020/12/cropped-1200px-Bitcoin.svg-32x32.png</url>
	<title>Cryptography &#8211; Specter Solutions | Your Keys, Your Bitcoin</title>
	<link>https://specter.solutions</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>ECDSA is not that bad: two-party signing without Schnorr or BLS</title>
		<link>https://specter.solutions/ecdsa-is-not-that-bad-two-party-signing-without-schnorr-or-bls/</link>
		
		<dc:creator><![CDATA[Stepan Snigirev]]></dc:creator>
		<pubDate>Sun, 14 Oct 2018 19:40:26 +0000</pubDate>
				<category><![CDATA[Bitcoin]]></category>
		<category><![CDATA[Cryptography]]></category>
		<category><![CDATA[Math]]></category>
		<guid isPermaLink="false">https://specter.solutions/?p=3583</guid>

					<description><![CDATA[I already wrote about Schnorr and BLS signatures and I think they are really great. One of the most exciting properties of these signature schemes is key aggregation — if we want to make a 2-of-2 multisignature address we just take our public keys and add them together. The signature will be also just a &#8230;<p class="read-more"> <a class="" href="https://specter.solutions/ecdsa-is-not-that-bad-two-party-signing-without-schnorr-or-bls/"> <span class="screen-reader-text">ECDSA is not that bad: two-party signing without Schnorr or BLS</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="3583" class="elementor elementor-3583">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-ea6e40b elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="ea6e40b" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-ae9203c" data-id="ae9203c" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-6744e86 elementor-widget elementor-widget-text-editor" data-id="6744e86" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">I already wrote about <a href="https://medium.com/@snigirev.stepan/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744" target="_blank" rel="noopener">Schnorr</a> and <a href="https://medium.com/@snigirev.stepan/bls-signatures-better-than-schnorr-5a7fe30ea716" target="_blank" rel="noopener">BLS</a> signatures and I think they are really great. One of the most exciting properties of these signature schemes is <em>key aggregation</em> — if we want to make a 2-of-2 multisignature address we just take our public keys and add them together. The signature will be also just a sum of two signatures. This is possible because both Schnorr and BLS are linear — the sum of the verification equations is also a valid equation.</p><p data-selectable-paragraph="">For example, to verify Schnorr signature <strong><em>(R, s) = (k×G, k+hash(P,R,m)⋅pk) </em></strong>we need to confirm that <strong><em>s×G = R + hash(P,R,m)×P</em></strong>. This means that if we use two private keys <strong><em>pk1, pk2 </em></strong>with corresponding public keys <strong><em>P1=pk1×G</em></strong>, <strong><em>P2=pk2×G</em></strong> we can add them up to get a multisig key <strong><em>P = P1+P2</em></strong>. And to generate a multisignature we just add our random numbers and signatures: <strong><em>(R, s) = (R1+R2, s1+s2)</em></strong>. We only need to agree on <strong><em>R=R1+R2</em></strong> in advance as it is used in the hash of the message. If the equations above look confusing to you, check out my <a href="https://medium.com/@snigirev.stepan/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744" target="_blank" rel="noopener">previous post on Schnorr signatures</a>.</p><p data-selectable-paragraph="">With <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener nofollow">ECDSA</a> everything is a bit more complicated. The verification equation is not linear. To generate a signature we need to choose a random number <strong><em>k</em></strong> with corresponding point <strong><em>R = k×G</em></strong> and compute <strong><em>s = (z+r⋅pk)/k</em></strong>. Here <strong><em>z=hash(m) </em></strong>is the hash of the message we are signing and <strong><em>r</em></strong> is an <strong><em>x-</em></strong>coordiante of our random point <strong><em>R</em></strong>. Annoying part here is this division by <strong><em>k</em></strong>. A simple addition of the equations doesn’t work anymore. But multiplication does! We just need to be careful with it. There is a nice trick shown in the <a href="https://eprint.iacr.org/2017/552.pdf" target="_blank" rel="noopener nofollow">paper</a> by Yehuda Lindell that allows us to do 2-party ECDSA and generate a common signature.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>2-party ECDSA at a glance</b></h3><p data-selectable-paragraph="">To make key aggregation work with ECDSA we need to use multiplication instead of addition. From two private keys <strong><em>pk1, pk2</em></strong> and corresponding public keys <strong><em>P1=pk1×G</em></strong>, <strong><em>P2=pk2×G</em></strong> we calculate an aggregated public key <strong><em>P=pk1×P2=pk2×P1=pk1⋅pk2×G</em></strong>. This is a standard <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener nofollow">Diffie-Helman key exchange</a> — every party takes the public key of another party and multiplies it by his private key. Now both parties know the common public key without exposing anything about their private keys.</p><p data-selectable-paragraph="">To generate a valid signature for the message <strong><em>m</em></strong> with hash <strong><em>z=hash(m)</em></strong> we need to generate two random numbers <strong><em>k1, k2 </em></strong>(one for every party) and then calculate somehow the signature <strong><em>(r, s)</em></strong>. Calculating <strong><em>r</em></strong> is easy — we do the same Diffie-Helman key exchange. Parties send each other their random points <strong><em>R1=k1×G</em></strong>,<strong><em> R2=k2×G</em></strong> and calculate common point <strong><em>R=k1×R2=k2×R1=k1⋅k2×G</em></strong>. The part with <strong><em>s</em></strong> is much more complicated — we need to compute <strong><em>s=(z+r⋅pk1⋅pk2)/k1/k2</em></strong> in such a way that private key and random number of one party stay unknown to another.</p><p data-selectable-paragraph="">For this purpose, we can use <a href="https://en.wikipedia.org/wiki/Homomorphic_encryption" target="_blank" rel="noopener nofollow">homomorphic encryption</a>, in particular, <a href="https://en.wikipedia.org/wiki/Paillier_cryptosystem" target="_blank" rel="noopener nofollow">Paillier scheme</a>. Homomorphic encryption is a wonderful tool — with it, we can do computations on the encrypted data without getting any knowledge of the data itself. I will explain how it works a bit later and for now try to imagine: we can send an encrypted secret to another party and he can add something to it, multiply it by some number and then return us the result without getting any information about what he just did. Sounds magical! And it really is. Modern cryptography is so exciting!</p><p data-selectable-paragraph="">To calculate our common signature we need to do the following: the first party encrypts his private key <strong><em>pk1</em></strong> and sends the encrypted value <strong><em>e(pk1)</em></strong> to another party. The second party, using this encrypted key, creates a partial signature <strong><em>s’=(z+r⋅e(pk1)⋅pk2)/k2</em></strong> and sends it back to the first party. As the private key of the first party is encrypted, the second party learns nothing about it. And as the second party uses both his private key <strong><em>pk2</em></strong> and his random number <strong><em>k2</em></strong>, the first party also learns nothing. Now, the first party can decrypt the returned value and divide it by <strong><em>k1</em></strong>. Finally, we get our signature <strong><em>s=(z+r⋅pk1⋅pk2)/k2/k1</em></strong>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2069372 elementor-widget elementor-widget-image" data-id="2069372" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img fetchpriority="high" decoding="async" width="895" height="1024" src="https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x-895x1024.png" class="attachment-large size-large" alt="" >Simplified diagram of 2-party ECDSA signing. Blue values are public points, red values are secret, orange text represents homomorphic encryption and decryption.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-fefa590 elementor-widget elementor-widget-text-editor" data-id="fefa590" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="9b0e" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Notice that we need to get an encrypted value of the private key <strong class="gm hk"><em class="hj">e(pk1)</em></strong><br />only once during the setup phase and then we can reuse it for every<br />signature in the future. Even more, thanks to the homomorphic properties<br />of the encryption scheme we can use <a class="ey hi" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener nofollow">HD wallets</a><br />to generate new encrypted children keys from the encrypted master key.<br />To derive a child key we only need to add a certain number to the parent<br />private key — we can easily do it homomorphically with the encrypted<br />master key we have.</p><p id="7748" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Unfortunately, this scheme works only for <em class="hj">two parties</em>. If we want to use arbitrary m-of-n multisignature with bare ECDSA we still can do it, but it requires a much <a class="ey hi" href="https://eprint.iacr.org/2016/013.pdf" target="_blank" rel="noopener nofollow">more complicated scheme</a>.<br />And it is 100 times slower. But even with only two parties we can do<br />many amazing things — all Lightning channels can appear as normal<br />transactions (pay-to-pubkeyhash), and we can even do <a class="ey hi" href="https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf" target="_blank" rel="noopener nofollow">scriptless scripts with ECDSA</a>.</p><h3 id="3a7a" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""> </h3><h3 id="3a7a" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""><b>Homomorphic encryption</b></h3><p id="2753" class="gk gl dn gm b gn ig gp gq gr ih gt gu gv ii gx gy gz ij hb hc hd ik hf hg hh dg ch" data-selectable-paragraph="">So how does this homomorphic magic work? As usual in cryptography, we use huge numbers everywhere. We start by choosing two large prime numbers <strong class="gm hk"><em class="hj">p</em></strong> and <strong class="gm hk"><em class="hj">q</em></strong> of the same length (if they have different lengths we need a <a class="ey hi" href="https://en.wikipedia.org/wiki/Paillier_cryptosystem" target="_blank" rel="noopener nofollow">fancier algorithm</a>). We will use their product <strong class="gm hk"><em class="hj">n=p⋅q</em></strong> and a number <strong class="gm hk"><em class="hj">g=n+1</em></strong> for encryption. These two numbers (<strong class="gm hk"><em class="hj">n</em></strong>, <strong class="gm hk"><em class="hj">g</em></strong>) are public and can be shared with anyone. Another pair of numbers, <strong class="gm hk"><em class="hj">λ=</em></strong><a class="ey hi" href="https://en.wikipedia.org/wiki/Least_common_multiple" target="_blank" rel="noopener nofollow"><strong class="gm hk"><em class="hj">lcm</em></strong></a><strong class="gm hk"><em class="hj">(p–1, q–1)=(p–1)⋅(q–1)/2</em></strong> and <strong class="gm hk"><em class="hj">µ=λ^–1 mod n </em></strong>are used for decryption. We need to keep them secret.</p><p id="8976" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">This <strong class="gm hk"><em class="hj">λ</em></strong> number is <a class="ey hi" href="https://en.wikipedia.org/wiki/Carmichael_function" target="_blank" rel="noopener nofollow">pretty interesting</a>. If we take <em class="hj">any</em> number <strong class="gm hk"><em class="hj">r</em></strong> and calculate <strong class="gm hk"><em class="hj">r^λ mod n</em></strong> we’ll get <strong class="gm hk"><em class="hj">1</em></strong>. If we calculate <strong class="gm hk"><em class="hj">r^(λ⋅n) mod n²</em></strong> we will also get <strong class="gm hk"><em class="hj">1</em></strong>. This means we can compute an inverse of a number as <strong class="gm hk"><em class="hj">r^(–1)=r^(λ-1) mod n</em></strong>. It also works for <strong class="gm hk"><em class="hj">λ</em></strong> itself:</p><p id="9652" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">µ=λ^–1 = λ^(λ–1) mod n</em></strong></p><p id="6666" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Now, to <em class="hj">encrypt</em> a secret number <strong class="gm hk"><em class="hj">x</em></strong> we pick a random number <strong class="gm hk"><em class="hj">r</em></strong> and compute encrypted value <strong class="gm hk"><em class="hj">e(x) = g^x ⋅ r^n mod n²</em></strong>. All the operations with encrypted data are happening modulo <strong class="gm hk"><em class="hj">n²</em></strong>. It is a pretty large number, so homomorphic calculations may be pretty slow and memory consuming. If we want to <em class="hj">add</em> a number <strong class="gm hk"><em class="hj">a</em></strong> to the value <strong class="gm hk"><em class="hj">x</em></strong> using only encrypted data we just multiply it by <strong class="gm hk"><em class="hj">g^a</em></strong>:</p><p id="4702" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">e(x)⋅g^a = g^(x+a)⋅ r^n mod n² = e(x+a)</em></strong></p><p id="c8cd" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">To <em class="hj">multiply</em> <strong class="gm hk"><em class="hj">x</em></strong> by some number <strong class="gm hk"><em class="hj">b</em></strong> we need to exponentiate the encrypted value:</p><p id="2ffc" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">e(x)^b=g^(x⋅b)⋅(r^b)^n mod n² = e(x⋅b)</em></strong></p><p id="900a" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">The random number changes from <strong class="gm hk"><em class="hj">r</em></strong> to <strong class="gm hk"><em class="hj">r^b</em></strong>, but we don’t really care. It’s just a different random number.</p><p id="8c6d" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">After we are done with the calculations we can <em class="hj">decrypt</em> the data and get the result. To extract <strong class="gm hk"><em class="hj">x </em></strong>from the cyphertext we do the following:</p><p id="1036" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">x = (e(x)^λ mod n² – 1) / n ⋅ µ mod n</em></strong></p><p id="0dfb" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Looks confusing. Let’s take a closer look. First, we take our cyphertext <strong class="gm hk"><em class="hj">e(x)</em></strong> and exponentiate it to the power of <strong class="gm hk"><em class="hj">λ</em></strong>:</p><p id="5181" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">e(x)^λ mod n² = g^(x⋅λ) ⋅ r^(n⋅λ) mod n² = g^(x⋅λ) mod n²</em></strong></p><p id="a1fe" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Here we used the fact that <strong class="gm hk"><em class="hj">r^(n⋅λ) mod n² = 1</em></strong> and <strong class="gm hk"><em class="hj">r</em></strong> part disappears.</p><p id="195f" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Now, recall that <strong class="gm hk"><em class="hj">g=n+1</em></strong>. Using <a class="ey hi" href="https://en.wikipedia.org/wiki/Binomial_theorem" target="_blank" rel="noopener nofollow">binomial theorem</a> we can expand <strong class="gm hk"><em class="hj">(1+n)^x </em></strong>and after taking it modulo <strong class="gm hk"><em class="hj">n²</em></strong> only first two terms will remain:</p><p id="8406" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">g^x mod n² = (1+n)^x mod n² = (1 + x⋅n + x⋅(x-1)/2 ⋅ n² + …) mod n² = (1+x⋅n)</em></strong></p><p id="95db" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">In our case we have:</p><p id="7df2" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">g^(λ⋅x) mod n² = (1 + λx⋅n + λx⋅(λx-1)/2 ⋅ n² + …) mod n² = 1 + λx⋅n</em></strong></p><p id="336f" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">From here we subtract <strong class="gm hk"><em class="hj">1</em></strong>, divide by <strong class="gm hk"><em class="hj">n</em></strong>, get rid of the <strong class="gm hk"><em class="hj">λ</em></strong> (multiplying by the inverse of it — <strong class="gm hk"><em class="hj">µ</em></strong>) and end up with pure <strong class="gm hk"><em class="hj">x</em></strong>.</p><p id="d746" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">If you don’t believe in the above — try it out by yourself. I wrote a tiny <a class="ey hi" href="https://github.com/stepansnigirev/2-party-ecdsa-playground/blob/master/paillier.ipynb" target="_blank" rel="noopener nofollow">jupyter notebook</a> just to make sure it works.</p><h3 id="408d" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""> </h3><h3 id="408d" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""><b>Further reading</b></h3><p id="ad3b" class="gk gl dn gm b gn ig gp gq gr ih gt gu gv ii gx gy gz ij hb hc hd ik hf hg hh dg ch" data-selectable-paragraph="">Here we discussed the basic idea of the algorithm, but there are a few things that are left outside of the scope of this post. In particular, the setup phase of the algorithm is a bit more complicated. The second party needs to make sure that the ciphertext he got from the first party corresponds to the public key <strong class="gm hk"><em class="hj">P1</em></strong>. So the first party needs to prove the connection between the ciphertext <strong class="gm hk"><em class="hj">e(pk1)</em></strong> and the public point <strong class="gm hk"><em class="hj">P1</em></strong>. This is quite tricky and computationally heavy and can take <em class="hj">a few seconds</em> on the modern computer. But as soon as the setup phase is done, all the signing happens pretty quickly — all the proofs there are fast.</p><p id="2275" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">There are more interesting things in the paper. I strongly recommend reading it if you can. Also, homomorphic encryption is really wonderful and I wrote only the core principle without going into details.</p><p id="39ac" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">And we didn’t discuss applications of this scheme in details. So check out these papers to find out more:</p><ul class=""><li id="155e" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="https://www.google.de/search?q=2+party+ecdsa&amp;oq=2+party+ecdsa&amp;aqs=chrome..69i57j69i60l2j69i61j69i59j69i64.4847j0j4&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener nofollow">Original paper by Lindell — Fast Secure Two-party ECDSA Signing</a></li><li id="5222" class="gk gl dn gm b gn jq gp gq gr jr gt gu gv js gx gy gz jt hb hc hd ju hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="http://www.cs.tau.ac.il/~fiat/crypt07/papers/Pai99pai.pdf" target="_blank" rel="noopener nofollow">Paillier paper on homomorphic scheme</a></li><li id="3a5d" class="gk gl dn gm b gn jq gp gq gr jr gt gu gv js gx gy gz jt hb hc hd ju hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf" target="_blank" rel="noopener nofollow">Scriptless scripts with ECDSA</a></li><li id="2e6c" class="gk gl dn gm b gn jq gp gq gr jr gt gu gv js gx gy gz jt hb hc hd ju hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="https://eprint.iacr.org/2018/472.pdf" target="_blank" rel="noopener nofollow">Multi-Hop Locks for Secure, Privacy-Preserving and Interoperable Payment-Channel Networks</a></li></ul>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>BLS signatures: better than Schnorr</title>
		<link>https://specter.solutions/bls-signatures-better-than-schnorr/</link>
		
		<dc:creator><![CDATA[Stepan Snigirev]]></dc:creator>
		<pubDate>Mon, 25 Jun 2018 21:30:09 +0000</pubDate>
				<category><![CDATA[Bitcoin]]></category>
		<category><![CDATA[Blockchain]]></category>
		<category><![CDATA[Cryptography]]></category>
		<category><![CDATA[Math]]></category>
		<guid isPermaLink="false">https://specter.solutions/?p=3671</guid>

					<description><![CDATA[In the previous post I wrote about Schnorr signatures and how awesome they are. This one is about Boneh-Lynn-Shacham signatures and their extremely nice features that are not possible with Schnorr. Shortly, what we know so far: ECDSA signatures are ok. They do their job and do it well, but nothing more. We can’t combine &#8230;<p class="read-more"> <a class="" href="https://specter.solutions/bls-signatures-better-than-schnorr/"> <span class="screen-reader-text">BLS signatures: better than Schnorr</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="3671" class="elementor elementor-3671">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-3d1382a elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="3d1382a" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-f3c4fbf" data-id="f3c4fbf" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-4aca3b1 elementor-widget elementor-widget-text-editor" data-id="4aca3b1" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">In the <a href="https://medium.com/@snigirev.stepan/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744" target="_blank" rel="noopener">previous post</a> I wrote about Schnorr signatures and how awesome they are. This one is about <a href="https://www.iacr.org/archive/asiacrypt2001/22480516.pdf" target="_blank" rel="noopener nofollow">Boneh-Lynn-Shacham</a> signatures and their <a href="https://eprint.iacr.org/2018/483.pdf" target="_blank" rel="noopener nofollow">extremely nice features</a> that are not possible with Schnorr.</p><p data-selectable-paragraph="">Shortly, what we know so far:</p><p data-selectable-paragraph="">ECDSA signatures are ok. They do their job and do it well, but nothing more. We can’t combine signatures or keys and every signature has to be verified independently. With multisig transactions, it becomes especially annoying. We have to check all the signatures and the corresponding public keys one by one, waste a lot of space in a block and pay large fees.</p><p data-selectable-paragraph="">Schnorr signatures are awesome — if we do it right we can combine all signatures and public keys in the transaction to a single key and a signature and nobody will find out that they correspond to multiple keys. Also block validation can be faster — we can validate all signatures at once. There are a few issues though:</p><ul><li data-selectable-paragraph="">Multisig scheme requires several communication rounds. This can be very annoying with cold storage.</li><li data-selectable-paragraph="">With signature aggregation we have to rely on random number generator — we can’t choose random point <strong><em>R</em></strong> deterministically like we do in ECDSA</li><li data-selectable-paragraph="">m-of-n multisig scheme is tricky — we need to make a merkle tree of public keys that can get pretty large for large m and n.</li><li data-selectable-paragraph="">We can‘t combine all signatures in the block to a single signature.</li></ul><p data-selectable-paragraph="">BLS signatures can fix all of the above. We don’t need random numbers <em>at all</em>, all signatures in the block can be combined to a single signature, m-of-n multisig is very simple and we don’t need several communication rounds between signers. In addition to that BLS signatures are 2 times shorter than Schnorr or ECDSA — signature is not a pair, but a single curve point. Sounds amazing! Let’s see how they work.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>BLS signatures magic</b></h3><p data-selectable-paragraph="">Before we start we need two new constructions — hashing to the curve and curves pairing.</p><p data-selectable-paragraph=""><b>Hashing to the curve</b></p><p data-selectable-paragraph="">Normally with ECDSA and Schnorr we hash the message and use this hash in the signing algorithm as a number. For BLS signatures we need a slightly modified hashing algorithm that hashes directly to the elliptic curve. The easiest way is to hash a message as usual and treat the result as an<br /><strong><em>x</em></strong>-coordinate of a point. Elliptic curves (like the one we are using in Bitcoin) usually have about 2²⁵⁶ points and SHA-256 hashing algorithm also gives a 256-bit result. But for every valid <strong><em>x</em></strong>-coordinate there are two points with positive and negative <strong><em>y</em></strong>-coordinate (just because if <strong><em>(x,y)</em></strong> is on the curve <strong><em>y²=x³+ax+b</em></strong> then <strong><em>(x,-y)</em></strong> is also on the curve). This means that our hash has roughly 50% probability to find two points for some <strong><em>x</em></strong> and 50% to find none.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-555c96f elementor-widget elementor-widget-image" data-id="555c96f" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img decoding="async" width="878" height="1024" src="https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x-878x1024.png" class="attachment-large size-large" alt="" >Toy example of hashing to the elliptic curve y²=x³+7 defined over finite field modulo 23. Only half of all x-coordinates have points. Here only third attempt was successful.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8c30fc0 elementor-widget elementor-widget-text-editor" data-id="8c30fc0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">To find a point <em>for any message</em> we can try hashing several times by appending a number to the message and incrementing it on fail. If <strong><em>hash(m||0)</em></strong> doesn’t find a point we try <strong><em>hash(m||1)</em></strong>, <strong><em>hash(m||2)</em></strong> and so on until we finally get one that matches. Then we choose one of the two corresponding points, say the one with smaller <strong><em>y</em></strong>, and we are done.</p><p data-selectable-paragraph=""><b>Curves pairing</b></p><p data-selectable-paragraph="">Another thing we need is a very special function that takes two points <strong><em>P</em></strong> and <strong><em>Q</em></strong> on a curve (or on two different curves) and maps them to a number:</p><p data-selectable-paragraph=""><strong><em>e(P, Q) → n</em></strong>.</p><p data-selectable-paragraph="">We also require one important property from this function. If we have some secret number <strong><em>x</em></strong> and two points <strong><em>P</em></strong> and <strong><em>Q</em></strong> we should obtain the same result regardless of which point we multiply by this number:</p><p data-selectable-paragraph=""><strong><em>e(x×P, Q) = e(P, x×Q)</em></strong>.</p><p data-selectable-paragraph="">Basically we need to be able to swap multipliers of the points between two arguments without changing the result. More generally all these swaps should give the same result:</p><p data-selectable-paragraph="">e(<strong><em>a×P, b×Q) = e(P, ab×Q) = e(ab×P, Q) = e(P, Q)^(ab)</em></strong></p><p data-selectable-paragraph="">I am not going to describe how exactly this function works. Underlying math is pretty complicated and if you want to know all the nasty details I would suggest reading <a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627" target="_blank" rel="noopener">this post</a> and references in it. If you want to go deeper — <a href="https://crypto.stanford.edu/pbc/thesis.pdf" target="_blank" rel="noopener nofollow">this thesis</a> is completely about pairings. For now we just accept that such functions exist and they don’t reveal any information about our secret number <strong><em>x</em></strong>.</p><p data-selectable-paragraph="">One important note is that we can’t use <em>any</em> elliptic curve here (in particular, standard Bitcoin curve secp256k1 doesn’t work). To make this function efficient and secure we have to use very special curves from “pairing-friendly” family.</p><p id="2f49" class="it hu dn au av iu iv iw hx ix iy iz ia ja jb jc ie jd je jf ii jg jh ji im jj ch" data-selectable-paragraph=""><b>BLS signature scheme</b></p><p id="a0e5" class="gk gl dn gm b gn io gp gq gr ip gt gu gv iq gx gy gz ir hb hc hd is hf hg hh dg ch" data-selectable-paragraph="">Now we have everything we need to construct a BLS signature. As usual our private key is some secret number <strong class="gm hr"><em class="hs">pk</em></strong>, our public key is <strong class="gm hr"><em class="hs">P = pk×G</em></strong> and the message we are signing is <strong class="gm hr"><em class="hs">m</em></strong>.</p><p id="5ba2" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">To calculate the signature we hash our message to the curve <strong class="gm hr"><em class="hs">H(m)</em></strong> and multiply resulting point by our private key: <strong class="gm hr"><em class="hs">S = pk×H(m)</em></strong>. That’s it! Nothing else — no random numbers, no extra operations, just a hash times the private key! Our signature is just one single point on the curve that takes only 33 bytes in compressed serialisation format!</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f7cf086 elementor-widget elementor-widget-image" data-id="f7cf086" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img decoding="async" width="1024" height="793" src="https://specter.solutions/wp-content/uploads/2021/01/1-IpmIdJLR36iHnOHq1OqHnw@2x-1024x793.png" class="attachment-large size-large" alt="" >BLS signature generation. To obtain signature we multiply a hash of the message by the private key.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9d453e4 elementor-widget elementor-widget-text-editor" data-id="9d453e4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="ec61" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">To verify this signature one can take our public key <strong class="gm hr"><em class="hs">P</em></strong> and check that</p><p id="1881" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hr"><em class="hs">e(P, H(m)) = e(G, S)</em></strong></p><p id="7627" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">It it true because of the nice property of the pairing function described above:</p><p id="4247" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hr"><em class="hs">e(P, H(m)) = e(pk×G, H(m)) = e(G, pk×H(m)) = e(G, S)</em></strong></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-641b5aa elementor-widget elementor-widget-image" data-id="641b5aa" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="1022" src="https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-1024x1022.png" class="attachment-large size-large" alt="" >BLS signature verification. We just need to check that the public key and the message hash are mapped to the same number as the curve generator point and the signature.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f55cc82 elementor-widget elementor-widget-text-editor" data-id="f55cc82" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>This signature scheme is beautiful and simple, but it also has several very nice features, especially for Bitcoin.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Signature aggregation</b></h3><p data-selectable-paragraph="">Now let’s combine all signatures in the block! Imagine we have a block with 1000 transactions and every transaction contains a signature <strong><em>Si</em></strong>, a public key <strong><em>Pi</em></strong> and a message that is signed <strong><em>mi</em></strong>. Why to store all the signatures if we can combine them? After all, we only care if all signatures in the block are valid. Aggregated signature will be just a sum of all signatures in the block:</p><p data-selectable-paragraph=""><strong><em>S = S1+S2+…+S1000</em></strong></p><p data-selectable-paragraph="">To verify the block we need to check that the following equality holds:</p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(P1, H(m1))⋅e(P2, H(m2))⋅…⋅e(P1000, H(m1000))</em></strong></p><p data-selectable-paragraph="">If you look carefully you will see that it’s indeed true:</p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(G, S1+S2+…+S1000) = e(G, S1)⋅e(G, S2)⋅…⋅e(G, S1000) = e(G, pk1×H(m1))⋅…⋅e(G, pk1000×H(m1000)) = e(pk1×G, H(m1))⋅…⋅e(pk1000×G, H(m1000)) = e(P1, H(m1))⋅e(P2, H(m2))⋅…⋅e(P1000, H(m1000))</em></strong></p><p data-selectable-paragraph="">We still need to know all the public keys and calculate 1001 pairing functions, but at least <em>all the signatures in the block take only 33 bytes</em>. Signature aggregation can be done by a miner and save a lot of space in the block.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Key aggregation and n-of-n multisignature</b></h3><p data-selectable-paragraph="">If we are using multisignature addresses, we are signing <em>the same transaction</em> with different keys. In this case we can do key aggregation like in Schnorr, where we combine all signatures and all keys to a single pair of a key and a signature. Let’s take a common 3-of-3 multisig scheme (it can be done similarly for any number of signers).</p><p data-selectable-paragraph="">A simple way to combine them is to add all the signatures and all the keys together. The result will be a signature <strong><em>S=S1+S2+S3</em></strong> and a key <strong><em>P=P1+P2+P3</em></strong>. It’s easy to see that the same verification equation still works:</p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(P, H(m))</em></strong></p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(G, S1+S2+S3) = e(G, (pk1+pk2+pk3)×H(m)) = e((pk1+pk2+pk3)×G, H(m)) = e(P1+P2+P3, H(m)) = e(P, H(m))</em></strong></p><p data-selectable-paragraph="">Just like in Schnorr we need to protect ourselves from the rogue key attack. We can do it either by asking every co-signer to prove that they have private keys for their public keys (by signing their public keys), or we can add some nonlinearity to the scheme and make rogue key attack impossible. Instead of just summing up all the keys and signatures we multiply them by a certain number and then add:</p><p data-selectable-paragraph=""><strong><em>S = a1×S1+a2×S2+a3×S3</em></strong></p><p data-selectable-paragraph=""><strong><em>P = a1×P1+a2×P2+a3×P3</em></strong></p><p data-selectable-paragraph="">Here coefficients of the signatures and keys are calculated deterministically from the public key of the signer and all other public keys:</p><p data-selectable-paragraph=""><strong><em>ai = hash(Pi, {P1,P2,P3})</em></strong></p><p data-selectable-paragraph="">For example it can be just a concatenation of the signer’s public key and the whole set of public keys used for signing: <strong><em>ai = hash(Pi||P1||P2||P3)</em></strong>.</p><p data-selectable-paragraph="">The same verification equation still works. There will be additional coefficients <strong><em>ai</em></strong> in the proof, but the logic remains.</p><p data-selectable-paragraph="">Nice thing about this scheme is that you don’t need several communication rounds between devices. You just need to know who are other signers, and you are all set. This is much simpler than 3-round multisig scheme for Schnorr signatures. It also doesn’t rely on any randomness, it is a <em>completely deterministic signature algorithm</em>.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Subgroup multisignature scheme (m-of-n multisig)</b></h3><p data-selectable-paragraph="">Often we don’t want to use n-of-n multisig scheme, we prefer to use m-of-n, say, 2-of-3. We don’t want to lose all our money just because we’ve lost one of our keys. It would be nice to use key aggregation in this scenario. With Schnorr signatures we were able to do so by using merkle tree of public keys. It is not the most efficient way, but it kinda works. Unfortunately, as soon as you go to high <strong><em>m</em></strong> and <strong><em>n</em></strong> values, merkle tree size blows up exponentially.</p><p data-selectable-paragraph="">With BLS signature scheme there is another method. It’s not that simple though. We will need a normal hash function that outputs a number — <strong><em>hash(x)</em></strong>, and a hash to the curve — <strong><em>H(x)</em></strong>. We will also need a “setup” phase when we decide to use multisig, but after this we don’t need to communicate anymore — we only need signatures to sign any amount of transactions.</p><p data-selectable-paragraph="">Again I will use a simple example where we want to construct 2-of-3 multisig scheme with keys stored on 3 different devices, but it can be extended to any values of <strong><em>m</em></strong> and <strong><em>n</em></strong>.</p><p data-selectable-paragraph=""><b>Setup phase</b></p><p data-selectable-paragraph="">Each of our devices has a signer’s number <strong><em>i = 1,2,3 </em></strong>that represent its place in a set, a private key <strong><em>pki </em></strong>and a corresponding public key <strong><em>Pi = pki×G</em></strong>. We calculate an aggregated public key exactly the same way as before:</p><p data-selectable-paragraph=""><strong><em>P = a1×P1+a2×P2+a3×P3, ai = hash(Pi, {P1,P2,P3})</em></strong></p><p data-selectable-paragraph="">Now every device needs to sign that number <strong><em>i</em></strong> is a member of our aggregated public key (for every <strong><em>i</em></strong>), aggregate these signatures and save the result on corresponding device:</p><p data-selectable-paragraph=""><strong><em>MKi = (a1⋅pk1)×H(P, i)+(a2⋅pk2)×H(P, i)+(a3⋅pk3)×H(P, i)</em></strong></p><p data-selectable-paragraph="">This signature we will call a “membership key” and we will use it later on for signing. Each membership key is a valid n-of-n signature of the message <strong><em>H(P,i)</em></strong>, it means that:</p><p data-selectable-paragraph=""><strong><em>e(G, MKi)=e(P, H(P,i))</em></strong></p><p data-selectable-paragraph="">Remember this equation, we will need it later. It will be used to prove that we are valid participants of the multisignature scheme.</p><p data-selectable-paragraph=""><b>Signing</b></p><p data-selectable-paragraph="">Now let’s say we want to sign a transaction only with keys <strong><em>pk1</em></strong> and <strong><em>pk3</em></strong>. We generate two signatures <strong><em>S1</em></strong> and <strong><em>S3</em></strong><em>:</em></p><p data-selectable-paragraph=""><strong><em>S1 = pk1×H(P, m)+MK1</em></strong>, <strong><em>S3=pk3×H(P, m)+MK3</em></strong></p><p data-selectable-paragraph="">and add them up to obtain single signature and key:</p><p data-selectable-paragraph=""><strong><em>(S’, P’) = (S1+S3, P1+P3)</em></strong></p><p data-selectable-paragraph="">I write <strong><em>P’</em></strong> and <strong><em>S’</em></strong> here to emphasise that this key and signature are signed only by <em>a subset </em>of signers and it not the same as <strong><em>P</em></strong> that is an aggregated key for <em>all signers</em>. To verify this 2-of-3 signature we need to check that:</p><p data-selectable-paragraph=""><strong><em>e(G, S’) = e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))</em></strong></p><p data-selectable-paragraph="">We remember that membership keys <strong><em>MK1</em></strong> and <strong><em>MK3</em></strong> are valid signatures for messages <strong><em>H(P, 1)</em></strong> and <strong><em>H(P, 3)</em></strong> signed by aggregated key <strong><em>P</em></strong>, so:</p><p data-selectable-paragraph=""><strong><em>e(G, S’) = e(G, S1+S3)=e(G, pk1×H(P, m)+pk3×H(P, m)+MK1+MK3) =e(G, pk1×H(P, m)+pk3×H(P, m))⋅e(G, MK1+MK3)=e(pk1×G+pk3×G, H(P, m))⋅e(P, H(P, 1)+H(P, 3))=e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))</em></strong></p><p data-selectable-paragraph="">That’s it. A bit more complicated than n-of-n, but still understandable.</p><p data-selectable-paragraph=""><b>Possible implementation</b></p><p data-selectable-paragraph="">To implement this multisignature scheme we will need to send money to an address corresponding to an aggregated public key <strong><em>P</em></strong> and say that we need at least two signatures. In Bitcoin scripting language locking script could look like this:</p><p data-selectable-paragraph=""><strong><em>OP_2 &lt;P&gt; OP_CHECK_BLS_MULTISIG</em></strong></p><p data-selectable-paragraph="">Here <strong><em>OP_2</em></strong> tells that we require two keys to sign the message. We don’t say anywhere that there are 3 signers in total, so one can’t say if it is 2-of-3 or 2-of-100 multisig address. We also don’t reveal this information later.</p><p data-selectable-paragraph="">To spend this output we need to provide a key <strong><em>P’</em></strong>, signature <strong><em>S’</em></strong> and indexes of participating signers — in our case numbers 1 and 3. Unlocking script could look like this:</p><p data-selectable-paragraph=""><strong><em>OP_1 OP_3 &lt;P’&gt; &lt;S’&gt;</em></strong></p><p data-selectable-paragraph="">Combining these scripts gives us all necessary information. From <strong><em>OP_1</em></strong> and <strong><em>OP_3</em></strong> we know that we need to calculate hashes <strong><em>H(P, 1)</em></strong> and <strong><em>H(P, 3)</em></strong>, and then we have everything we need to verify the transaction.</p><p data-selectable-paragraph="">This means that for <em>any </em><strong><em>m</em></strong><em> and </em><strong><em>n</em></strong> we need only:</p><ul><li data-selectable-paragraph="">one aggregated public key <strong><em>P</em></strong> in the locking script</li><li data-selectable-paragraph="">one aggregated public key of participating signers <strong><em>P’</em></strong></li><li data-selectable-paragraph="">one aggregated signature <strong><em>S’</em></strong></li><li data-selectable-paragraph=""><strong><em>m</em></strong> numbers with signer’s indexes.</li></ul><p data-selectable-paragraph="">It is very compact and beautiful!</p><p data-selectable-paragraph="">There is only one thing that I don’t like here… Normally we use addresses only once — we use key derivation like BIP32 to generate new private keys and addresses. But for every new set of private keys we also need a set of new membership keys. One way to do it without running through setup phase every time is to generate a bunch of keys, like 1000 of them and get corresponding membership keys. After all, they are just 32-byte long. Then we will need to run the setup phase again only when all 1000 addresses are used.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Drawbacks</b></h3><p data-selectable-paragraph="">As it was pointed out in the comments here and on twitter, I skipped one important part and made you think that BLS signatures are perfect. They are not. And thanks a lot for bringing this up!</p><p data-selectable-paragraph=""><em>Pairing is hard</em>. I completely skipped that part and we considered that our magic function <strong><em>e(P, Q)</em></strong> is efficient and secure. It is not exactly true.</p><p data-selectable-paragraph=""><b>Paring is not so efficient</b></p><p data-selectable-paragraph="">BLS signature verification is order of magnitude harder than ECDSA. Signature aggregation for the whole block with 1000 transactions still requires to compute 1000 pairing, so verifying one tiny signature in a block may take longer than verifying 1000 separate ECDSA signatures. The only benefit we achieve here is that we can fit more transactions in the block as aggregated signature takes only ~32 bytes.</p><p data-selectable-paragraph="">Unlike BLS, Schnorr signatures are very efficient — they can be validated all together and this process is factor of 3 more efficient than ECDSA. The question then arises: what is more important for us?</p><p data-selectable-paragraph=""><b>Security proof is harder</b></p><p data-selectable-paragraph="">Pairing functions are complicated, and it can become our foe if we are not careful enough. On the one hand we want pairing to be efficient to verify signatures faster, on the other hand we don’t want to reveal any information about our secret key. These two requirements fight each other and we need to be extremely careful with our choice of pairing-friendly curves.</p><p data-selectable-paragraph="">There is actually an attack on elliptic curve crypto systems, called <a href="https://sci-hub.tw/https://ieeexplore.ieee.org/document/259647/" target="_blank" rel="noopener nofollow">MOV attack</a> (named after Menezes, Okamoto, and Vanstone), that allows to reduce security of the system by using our magic pairing function. So we really need to be careful here.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Conclusion</b></h3><p data-selectable-paragraph="">BLS signatures are amazing — we can combine all signatures in a block to a single signature, we can use key aggregation and m-of-n multisig scheme without additional communication rounds, we don’t need to rely on random number generators and the scheme itself looks very nice and simple. There is still room for improvement, standardising and optimising everything will take some time. But I hope at some point this signature algorithm will become good enough to be included in the Bitcoin protocol and we will be able to use all these nice features with smaller and more aggregatable signatures.</p><p data-selectable-paragraph="">I am very excited to see the first author Dan Boneh working on cryptocurrencies. He is a great cryptographer and his <a href="https://www.coursera.org/learn/crypto" target="_blank" rel="noopener nofollow">coursera crypto course</a> is outstanding. I also recommend his <a href="http://toc.cryptobook.us/" target="_blank" rel="noopener nofollow">crypto book</a> even though it’s not finished yet. I am sure we will see many interesting schemes and protocol improvements from him and his team in the near future.</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How Schnorr signatures may improve Bitcoin</title>
		<link>https://specter.solutions/how-schnorr-signatures-may-improve-bitcoin/</link>
		
		<dc:creator><![CDATA[Stepan Snigirev]]></dc:creator>
		<pubDate>Sat, 23 Jun 2018 22:09:26 +0000</pubDate>
				<category><![CDATA[Bitcoin]]></category>
		<category><![CDATA[Blockchain]]></category>
		<category><![CDATA[Cryptography]]></category>
		<category><![CDATA[Math]]></category>
		<guid isPermaLink="false">https://specter.solutions/?p=3703</guid>

					<description><![CDATA[When I was reading the MuSig paper from Blockstream I was trying to imagine what would it mean for me as a bitcoin user. Some features of the Schnorr signatures I found really great and convenient, but others are pretty annoying. Here I want to share my thoughts with you, but first, a quick recap: &#8230;<p class="read-more"> <a class="" href="https://specter.solutions/how-schnorr-signatures-may-improve-bitcoin/"> <span class="screen-reader-text">How Schnorr signatures may improve Bitcoin</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="3703" class="elementor elementor-3703">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-3f79218 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="3f79218" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-115b6f5" data-id="115b6f5" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-0c072e9 elementor-widget elementor-widget-text-editor" data-id="0c072e9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">When I was reading the <a href="https://eprint.iacr.org/2018/068.pdf" target="_blank" rel="noopener nofollow">MuSig</a> paper from Blockstream I was trying to imagine what would it mean for me as a bitcoin user. Some features of the Schnorr signatures I found really great and convenient, but others are pretty annoying. Here I want to share my thoughts with you, but first, a quick recap:</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Elliptic Curve Digital Signature Algorithm</b></h3><p data-selectable-paragraph="">Currently in Bitcoin we use <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener nofollow">ECDSA</a>. To sign a message <strong><em>m</em></strong> we hash it and treat this hash as a number: <strong><em>z = hash(m)</em></strong>. We also need a random or random-looking number <strong><em>k</em></strong>. We prefer not to trust random number generators (too many failures and vulnerabilities are related to bad RGNs) so we usually use <a href="https://tools.ietf.org/html/rfc6979" target="_blank" rel="noopener nofollow">RFC6979</a> to calculate <strong><em>deterministic k</em></strong> based on our secret and the message we are signing.</p><p data-selectable-paragraph="">Using a private key <strong><em>pk</em></strong> we can generate a signature for message <strong><em>m</em></strong> consisting of two numbers: <strong><em>r</em></strong> (<strong><em>x</em></strong> coordinate of the random point <strong><em>R = k×G</em></strong>) and <strong><em>s = (z+r⋅pk)/k</em></strong>. Then, using our public key <strong><em>P = pk×G</em></strong> anyone can verify our signature by checking that point <strong><em>(z/s)×G+(r/s)×P</em></strong> has <strong><em>x </em></strong>coordinate equal to <strong><em>r</em></strong>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-510ab4e elementor-widget elementor-widget-image" data-id="510ab4e" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="991" height="1024" src="https://specter.solutions/wp-content/uploads/2021/01/1-aWEbhqQIpHXZgvNpRSi54g@2x-991x1024.png" class="attachment-large size-large" alt="" >Visualisation of the ECDSA algorithm. Elliptic curve is plotted over real numbers for illustration purposes.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ae98166 elementor-widget elementor-widget-text-editor" data-id="ae98166" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">This algorithm is very common and pretty nice but it can be improved. First, signature verification includes inversion (<strong><em>1/s</em></strong>) and two points multiplications and these operations are very computationally heavy. In Bitcoin every node has to verify all the transactions. This means that when you broadcast a transaction, thousands of computers will have to verify your signature. Making verification process simpler will be very beneficial even if signing process is harder.</p><p data-selectable-paragraph="">Second, every node has to verify every signature separately. In case of m-of-n multisig transaction node may even have to verify the same signature several times. For example, transaction with 7-of-11 multisig input will contain 7 signatures and require from 7 to 11 signature verifications <em>on every node</em> in the network. Also such transaction will take a huge amount of space in the block and you will have to pay large fees for that.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Schnorr signatures</b></h3><p data-selectable-paragraph="">Schnorr signatures are generated slightly differently. Instead of two scalars <strong><em>(r,s)</em></strong> we use a point <strong><em>R</em></strong> and a scalar <strong><em>s</em></strong>. Similar to ECDSA, <strong><em>R</em></strong> is a random point on elliptic curve (<strong><em>R = k×G</em></strong>). Second part of the signature is calculated slightly differently: <strong><em>s = k + hash(P,R,m) ⋅ pk</em></strong>. Here <strong><em>pk</em></strong> is your private key, <strong><em>P = pk×G </em></strong>is your public key, <strong><em>m</em></strong> is the message. Then one can verify this signature by checking that <strong><em>s×G = R + hash(P,R,m)×P</em></strong>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ed9fca2 elementor-widget elementor-widget-image" data-id="ed9fca2" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="956" src="https://specter.solutions/wp-content/uploads/2021/01/1-hIjYiOdjwBVqdRpa5lrJOg@2x-1024x956.png" class="attachment-large size-large" alt="" >Visualisation of the Schnorr signature verification.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7e57c62 elementor-widget elementor-widget-text-editor" data-id="7e57c62" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="7439" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">This equation is linear, so equations can be added and subtracted with each other and still stay valid. This brings us to several nice features of Schnorr signatures that we can use.</p><p id="8907" class="jp hk dn au av jq jr js hn jt ju jv hq jw jx jy hu jz ka kb hy kc kd ke ic kf ch" data-selectable-paragraph=""><b>1. Batch validation</b></p><p id="2bc6" class="gk gl dn gm b gn ie gp gq gr if gt gu gv ig gx gy gz ih hb hc hd ii hf hg hh dg ch" data-selectable-paragraph="">To verify a block in Bitcoin blockchain we need to make sure that <em class="ik">all</em> signatures in the block are valid. If one of them is not valid we don’t care which one — we just reject the whole block and that’s it.</p><p id="02ff" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">With ECDSA every signature has to be verified separately. Meaning that if we have 1000 signatures in the block we will need to compute 1000 inversions and 2000 point multiplications. In total ~3000 heavy operations.</p><p id="7e75" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">With Schnorr signatures we can add up all the signature verification equations and save some computational power. In total for a block with 1000 transactions we need to verify that:</p><p id="e4c6" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm ij"><em class="ik">(s1+s2+…+s1000)×G=(R1+…+R1000)+(hash(P1,R1,m1)×P1+ hash(P2,R2,m2)×P2+…+hash(P1000,R1000,m1000)×P1000)</em></strong></p><p id="3619" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Here we have a bunch of point additions (almost free in sense of computational power) and 1001 point multiplication. This is already a factor of 3 improvement — we need to compute roughly one heavy operation per signature.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8e2f49f elementor-widget elementor-widget-image" data-id="8e2f49f" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="364" src="https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-1024x364.png" class="attachment-large size-large" alt="" >Batch validation of two signatures. As verification equation is linear the sum of several equations is valid as soon as all signatures are valid. We save some computational power as scalar and point additions are much easier than point multiplication.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7d20e8b elementor-widget elementor-widget-text-editor" data-id="7d20e8b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph=""><b>2. Key aggregation</b></p><p data-selectable-paragraph="">We want to keep our bitcoins safe, so we might want to use at least two different private keys to control bitcoins. One we will use on a laptop or a phone and another one — on a hardware wallet / cold wallet. So when one of them is compromised we still have control over our bitcoins.</p><p data-selectable-paragraph="">Currently it is implemented via 2-of-2 multisig script. This requires two separate signatures to be included in the transaction.</p><p data-selectable-paragraph="">With Schnorr signatures we can use a pair of private keys <strong><em>(pk1,pk2)</em></strong> and generate a shared signature corresponding to a shared public key <strong><em>P=P1+P2=pk1×G+pk2×G</em></strong>. To generate this signature we need to choose a random number on every device <strong><em>(k1,k2)</em></strong>, generate a random point <strong><em>Ri=ki×G</em></strong>, add them up to calculate a common <strong><em>hash(P,R1+R2,m)</em></strong> and then get <strong><em>s1</em></strong> and <strong><em>s2</em></strong> from every device (<strong><em>si = ki + hash(P,R,m) ⋅ pki</em></strong>). Then we can add up these signatures and use a pair <strong><em>(R, s) = (R1+R2, s1+s2)</em></strong> as our signature for shared public key <strong><em>P</em></strong>. Everyone else won’t be able to say if it is an aggregated signature or not — it looks exactly the same as a normal Schnorr signature.</p><p data-selectable-paragraph="">There are three problems with this construction. First one — from UI point of view. To make a transaction we need several communication rounds — to calculate common <strong><em>R</em></strong>, and then — to sign. With two private keys it can be done with a single access to the cold wallet: we prepare an unsigned transaction on our online wallet, choose <strong><em>k1</em></strong> and write down <strong><em>R1=k1×G </em></strong>together with the unsigned transaction. Then we transfer this data to the cold wallet and sign. As we already have <strong><em>R1</em></strong> we can sign transaction on the cold wallet in one run. From the cold wallet we get <strong><em>R2 </em></strong>and <strong><em>s2</em></strong> which we transfer back to the online wallet. Online wallet signs the transaction with previously chosen <strong><em>(k1, R1)</em></strong>, combines both signatures and broadcasts a signed transaction. This is pretty much similar to what we have now, but as soon as you add a third private key everything becomes more complicated. Imagine you have a fortune that is controlled by 10 private keys stored in different secure places around the world and you need to make a transaction. Currently you need to go over all these places only once, but if you are using key aggregation you need to do it twice — to assemble all <strong><em>Ri</em></strong> and then to sign. In this case it would probably be better to stay with separate signatures without aggregation — then only one round is necessary.</p><p data-selectable-paragraph=""><em>Post update, thanks to Manu Drijvers for bringing this up</em>:<em> for a provably secure multisignature scheme you need 3 communication rounds:</em></p><ul><li data-selectable-paragraph=""><em>Choose a random number </em><strong><em>ki</em></strong><em> and corresponding </em><strong><em>Ri=ki×G</em></strong><em> and tell everyone only it’s hash </em><strong><em>ti=hash(Ri)</em></strong><em>, so that everyone can be sure that you will not change your mind after learning other’s random numbers,</em></li><li data-selectable-paragraph=""><em>Gather all the numbers </em><strong><em>Ri</em></strong><em> together and calculate common </em><strong><em>R</em></strong></li><li data-selectable-paragraph=""><em>Sign</em></li></ul><p data-selectable-paragraph="">Second problem is a known Rogue key attack. It is nicely described in the paper or <a href="https://bitcointechtalk.com/scaling-bitcoin-schnorr-signatures-abe3b5c275d1" target="_blank" rel="noopener nofollow">here</a>, so I won’t go into details. The idea is that if one of your devices is hacked (say, your online wallet) and pretends that its public key is <strong><em>(P1-P2)</em></strong> then it can control shared funds with its private key <strong><em>pk1</em></strong>. A simple solution is to require a public key to be signed with corresponding private key when we are setting up the devices.</p><p data-selectable-paragraph="">And there is a third important problem. <em>You can’t use deterministic k</em> <em>for signing</em>. There is a simple attack that allows a hacker to get our private key if you are using deterministic <strong><em>k</em></strong>. Attack looks like this: someone hacked our laptop and has a complete control over one of two private keys (say, <strong><em>pk1</em></strong>). We feel safe as our bitcoins require an aggregated signature from both <strong><em>pk1</em></strong> and <strong><em>pk2</em></strong>. So we are trying to make a transaction as usual, prepare an unsigned transaction and <strong><em>R1</em></strong> value, transfer them to our hardware wallet and sign there. Then transfer back <strong><em>(R2, s2)</em></strong> and… something happened to our online wallet and it fails to sign and broadcast. We try to do it again, but our hacked computer uses another random value this time — <strong><em>R1&#8242;</em></strong>. We sign the same transaction with our hardware wallet again and bring values <strong><em>(R2, s2&#8242;)</em></strong> back to our hacked computer. Ups, we’ve lost all our bitcoins.</p><p data-selectable-paragraph="">In this attack hacker gets a pair of valid signatures for the same transaction: <strong><em>(R1, s1, R2, s2)</em></strong> and <strong><em>(R1&#8242;, s1&#8242;, R2, s2&#8242;)</em></strong>. Here <strong><em>R2</em></strong> is the same, but <strong><em>R = R1+R2</em></strong> and <strong><em>R&#8217;=R1&#8217;+R2</em></strong> are different. This means that the hacker can calculate our second private key: <strong><em>s2-s2&#8217;=(hash(P,R1+R2,m)-hash(P,R1&#8217;+R2,m))⋅pk2</em></strong> and <strong><em>pk2=(s2-s2&#8242;)/(hash(P,R1+R2,m)-hash(P,R1&#8217;+R2,m))</em></strong>. I find this the most inconvenient feature of key aggregation — we will need to use a good random number generators everywhere to use key aggregation.</p><p data-selectable-paragraph=""><b>3. MuSig</b></p><p data-selectable-paragraph=""><a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" target="_blank" rel="noopener nofollow">MuSig</a> solves one of these problem — it makes rogue key attack impossible. The goal is to aggregate signatures and public keys from several parties/devices to a single one but without proving that you have a private key corresponding to the public key.</p><p data-selectable-paragraph="">The aggregated signature corresponds to the aggregated public key. But instead of just adding up public keys of all co-signers we multiply them to some factor. The aggregated public key will be <strong><em>P=hash(L,P1)×P1+…+hash(L,Pn)×Pn</em></strong>. Here <strong><em>L=hash(P1,…,Pn)</em></strong> — a common number depending on all public keys. This nonlinearity prevents attacker from constructing a bad public key like in rogue key attack. Even though the attacker knows exactly what should be his <strong><em>hash(L,Patk)×Patk</em></strong>, he can’t derive <strong><em>Patk</em></strong> from it — it is the same problem as to derive the private key from the public key.</p><p data-selectable-paragraph="">The rest is pretty similar to the previous case. To generate a signature each co-signer choses a random number <strong><em>ki</em></strong> and shares <strong><em>Ri=ki×G</em></strong> with others. Then they add up all these random points to a single <strong><em>R=R1+…+Rn</em></strong> and generate a signature <strong><em>si = ki + hash(P,R,m) ⋅ hash(L,Pi) ⋅ pki</em></strong>. The aggregated signature is <strong><em>(R, s)=(R1+…+Rn, s1+…+sn)</em></strong> and verification equation is the same as before: <strong><em>s×G = R + hash(P,R,m)×P</em></strong>.</p><p data-selectable-paragraph=""><b>4. Merkle Multisig</b></p><p data-selectable-paragraph="">As you may have noticed, MuSig and key aggregation require <em>all signers to sign a transaction</em>. But what if you want to make a 2-of-3 multisig? Is it possible at all to use signature aggregation in this case, or we will have to use our usual OP_CHECKMULTISIG and separate signatures?</p><p data-selectable-paragraph="">Well, it is possible, but with a small change in the protocol. We can develop a new op-code similar to OP_CHECKMULTISIG that checks if aggregated signature corresponds to a particular item in the Merkle tree of public keys.</p><p data-selectable-paragraph="">For example, if we use a 2-of-3 multisig with public keys <strong><em>P1</em></strong>, <strong><em>P2</em></strong> and <strong><em>P3</em></strong>, then we need to construct a Merkle tree of aggregated public keys for all combinations we can use: <strong><em>(P1, P2)</em></strong>, <strong><em>(P2, P3)</em></strong>, <strong><em>(P1, P3)</em></strong> and put the root in the locking script. To spend bitcoins we provide a signature and a proof that our public key is in the tree. For 2-of-3 multisig there are only 3 elements in the tree and the proof will consist of two hashes — the one we want to use and its neighbour. For 7-of-11 multisig there will be already 11!/7!/4!=330 possible key combinations and the proof will require 8 elements. In general the number of elements in the proof scales almost linear with the number of keys in multisig (it’s <strong><em>log2(n!/m!/(n-m)! </em></strong>).</p><p data-selectable-paragraph="">But with the Merkle tree of public keys we are not limited to m-of-n multisigs. We can make a tree with any public keys we want. For example, if we have a laptop, a phone, a hardware wallet and a recovery seed we can construct a structure that would allow us to spend bitcoins with a laptop and a hardware wallet, a phone and a hardware wallet or just with a recovery seed. This is currently not possible just with OP_CHECKMULTISIG — only if you construct much more complicated script with branches and stuff.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c435b58 elementor-widget elementor-widget-image" data-id="c435b58" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="425" src="https://specter.solutions/wp-content/uploads/2021/01/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-1024x425.png" class="attachment-large size-large" alt="" >Merkle tree of aggregated public keys. More than just m-of-n multisig.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7ab0a1c elementor-widget elementor-widget-text-editor" data-id="7ab0a1c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h3 data-selectable-paragraph=""><b>Conclusion</b></h3><p data-selectable-paragraph="">Schnorr signatures are great. They can save some computational power during block validation and also give us ability to use key aggregation. The last one has some inconveniences, but we aren’t forced to use them — after all, if we want we can continue using normal multisig schemes with separate, non-aggregated signatures and still gain something. I can’t wait to start using them and I hope they will be included in the Bitcoin protocol soon.</p><p data-selectable-paragraph="">I really liked the <a href="https://eprint.iacr.org/2018/068.pdf" target="_blank" rel="noopener nofollow">paper</a>, the MuSig scheme is smart and the paper itself is very easy to read. I would strongly recommend to look through it if you have time.</p><p data-selectable-paragraph="">P.S. There is also another nice type of signatures — BLS signatures. They look even better than Schnorr in some sense. If you want to know what BLS signatures are about, take a look at my <a href="https://medium.com/@snigirev.stepan/bls-signatures-better-than-schnorr-5a7fe30ea716" target="_blank" rel="noopener">next post</a>.</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
