{"id":3671,"date":"2018-06-25T21:30:09","date_gmt":"2018-06-25T21:30:09","guid":{"rendered":"https:\/\/specter.solutions\/?p=3671"},"modified":"2021-10-19T09:53:49","modified_gmt":"2021-10-19T09:53:49","slug":"bls-signatures-better-than-schnorr","status":"publish","type":"post","link":"https:\/\/specter.solutions\/bls-signatures-better-than-schnorr\/","title":{"rendered":"BLS signatures: better than Schnorr"},"content":{"rendered":"\t\t<div data-elementor-type=\"wp-post\" data-elementor-id=\"3671\" class=\"elementor elementor-3671\">\n\t\t\t\t\t\t<div class=\"elementor-inner\">\n\t\t\t\t<div class=\"elementor-section-wrap\">\n\t\t\t\t\t\t\t\t\t<section class=\"elementor-section elementor-top-section elementor-element elementor-element-3d1382a elementor-section-boxed elementor-section-height-default elementor-section-height-default\" data-id=\"3d1382a\" data-element_type=\"section\">\n\t\t\t\t\t\t<div class=\"elementor-container elementor-column-gap-default\">\n\t\t\t\t\t\t\t<div class=\"elementor-row\">\n\t\t\t\t\t<div class=\"elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-f3c4fbf\" data-id=\"f3c4fbf\" data-element_type=\"column\">\n\t\t\t<div class=\"elementor-column-wrap elementor-element-populated\">\n\t\t\t\t\t\t\t<div class=\"elementor-widget-wrap\">\n\t\t\t\t\t\t<div class=\"elementor-element elementor-element-4aca3b1 elementor-widget elementor-widget-text-editor\" data-id=\"4aca3b1\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p data-selectable-paragraph=\"\">In the <a href=\"https:\/\/medium.com\/@snigirev.stepan\/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744\" target=\"_blank\" rel=\"noopener\">previous post<\/a> I wrote about Schnorr signatures and how awesome they are. This one is about <a href=\"https:\/\/www.iacr.org\/archive\/asiacrypt2001\/22480516.pdf\" target=\"_blank\" rel=\"noopener nofollow\">Boneh-Lynn-Shacham<\/a> signatures and their <a href=\"https:\/\/eprint.iacr.org\/2018\/483.pdf\" target=\"_blank\" rel=\"noopener nofollow\">extremely nice features<\/a> that are not possible with Schnorr.<\/p><p data-selectable-paragraph=\"\">Shortly, what we know so far:<\/p><p data-selectable-paragraph=\"\">ECDSA signatures are ok. They do their job and do it well, but nothing more. We can\u2019t combine signatures or keys and every signature has to be verified independently. With multisig transactions, it becomes especially annoying. We have to check all the signatures and the corresponding public keys one by one, waste a lot of space in a block and pay large fees.<\/p><p data-selectable-paragraph=\"\">Schnorr signatures are awesome \u2014 if we do it right we can combine all signatures and public keys in the transaction to a single key and a signature and nobody will find out that they correspond to multiple keys. Also block validation can be faster \u2014 we can validate all signatures at once. There are a few issues though:<\/p><ul><li data-selectable-paragraph=\"\">Multisig scheme requires several communication rounds. This can be very annoying with cold storage.<\/li><li data-selectable-paragraph=\"\">With signature aggregation we have to rely on random number generator \u2014 we can\u2019t choose random point <strong><em>R<\/em><\/strong> deterministically like we do in ECDSA<\/li><li data-selectable-paragraph=\"\">m-of-n multisig scheme is tricky \u2014 we need to make a merkle tree of public keys that can get pretty large for large m and n.<\/li><li data-selectable-paragraph=\"\">We can\u2018t combine all signatures in the block to a single signature.<\/li><\/ul><p data-selectable-paragraph=\"\">BLS signatures can fix all of the above. We don\u2019t need random numbers <em>at all<\/em>, all signatures in the block can be combined to a single signature, m-of-n multisig is very simple and we don\u2019t need several communication rounds between signers. In addition to that BLS signatures are 2 times shorter than Schnorr or ECDSA \u2014 signature is not a pair, but a single curve point. Sounds amazing! Let\u2019s see how they work.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>BLS signatures magic<\/b><\/h3><p data-selectable-paragraph=\"\">Before we start we need two new constructions \u2014 hashing to the curve and curves pairing.<\/p><p data-selectable-paragraph=\"\"><b>Hashing to the curve<\/b><\/p><p data-selectable-paragraph=\"\">Normally with ECDSA and Schnorr we hash the message and use this hash in the signing algorithm as a number. For BLS signatures we need a slightly modified hashing algorithm that hashes directly to the elliptic curve. The easiest way is to hash a message as usual and treat the result as an<br \/><strong><em>x<\/em><\/strong>-coordinate of a point. Elliptic curves (like the one we are using in Bitcoin) usually have about 2\u00b2\u2075\u2076 points and SHA-256 hashing algorithm also gives a 256-bit result. But for every valid <strong><em>x<\/em><\/strong>-coordinate there are two points with positive and negative <strong><em>y<\/em><\/strong>-coordinate (just because if <strong><em>(x,y)<\/em><\/strong> is on the curve <strong><em>y\u00b2=x\u00b3+ax+b<\/em><\/strong> then <strong><em>(x,-y)<\/em><\/strong> is also on the curve). This means that our hash has roughly 50% probability to find two points for some <strong><em>x<\/em><\/strong> and 50% to find none.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-555c96f elementor-widget elementor-widget-image\" data-id=\"555c96f\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"878\" height=\"1024\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-3ONrQQr0leQSUCaKeBXITA@2x-878x1024.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-3ONrQQr0leQSUCaKeBXITA@2x-878x1024.png 878w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-3ONrQQr0leQSUCaKeBXITA@2x-257x300.png 257w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-3ONrQQr0leQSUCaKeBXITA@2x-768x896.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-3ONrQQr0leQSUCaKeBXITA@2x-1317x1536.png 1317w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-3ONrQQr0leQSUCaKeBXITA@2x-600x700.png 600w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-3ONrQQr0leQSUCaKeBXITA@2x.png 1400w\" sizes=\"(max-width: 878px) 100vw, 878px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">Toy example of hashing to the elliptic curve y\u00b2=x\u00b3+7 defined over finite field modulo 23. Only half of all x-coordinates have points. Here only third attempt was successful.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-8c30fc0 elementor-widget elementor-widget-text-editor\" data-id=\"8c30fc0\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p data-selectable-paragraph=\"\">To find a point <em>for any message<\/em> we can try hashing several times by appending a number to the message and incrementing it on fail. If <strong><em>hash(m||0)<\/em><\/strong> doesn\u2019t find a point we try <strong><em>hash(m||1)<\/em><\/strong>, <strong><em>hash(m||2)<\/em><\/strong> and so on until we finally get one that matches. Then we choose one of the two corresponding points, say the one with smaller <strong><em>y<\/em><\/strong>, and we are done.<\/p><p data-selectable-paragraph=\"\"><b>Curves pairing<\/b><\/p><p data-selectable-paragraph=\"\">Another thing we need is a very special function that takes two points <strong><em>P<\/em><\/strong> and <strong><em>Q<\/em><\/strong> on a curve (or on two different curves) and maps them to a number:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(P, Q) \u2192 n<\/em><\/strong>.<\/p><p data-selectable-paragraph=\"\">We also require one important property from this function. If we have some secret number <strong><em>x<\/em><\/strong> and two points <strong><em>P<\/em><\/strong> and <strong><em>Q<\/em><\/strong> we should obtain the same result regardless of which point we multiply by this number:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(x\u00d7P, Q) = e(P, x\u00d7Q)<\/em><\/strong>.<\/p><p data-selectable-paragraph=\"\">Basically we need to be able to swap multipliers of the points between two arguments without changing the result. More generally all these swaps should give the same result:<\/p><p data-selectable-paragraph=\"\">e(<strong><em>a\u00d7P, b\u00d7Q) = e(P, ab\u00d7Q) = e(ab\u00d7P, Q) = e(P, Q)^(ab)<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">I am not going to describe how exactly this function works. Underlying math is pretty complicated and if you want to know all the nasty details I would suggest reading <a href=\"https:\/\/medium.com\/@VitalikButerin\/exploring-elliptic-curve-pairings-c73c1864e627\" target=\"_blank\" rel=\"noopener\">this post<\/a> and references in it. If you want to go deeper \u2014 <a href=\"https:\/\/crypto.stanford.edu\/pbc\/thesis.pdf\" target=\"_blank\" rel=\"noopener nofollow\">this thesis<\/a> is completely about pairings. For now we just accept that such functions exist and they don\u2019t reveal any information about our secret number <strong><em>x<\/em><\/strong>.<\/p><p data-selectable-paragraph=\"\">One important note is that we can\u2019t use <em>any<\/em> elliptic curve here (in particular, standard Bitcoin curve secp256k1 doesn\u2019t work). To make this function efficient and secure we have to use very special curves from \u201cpairing-friendly\u201d family.<\/p><p id=\"2f49\" class=\"it hu dn au av iu iv iw hx ix iy iz ia ja jb jc ie jd je jf ii jg jh ji im jj ch\" data-selectable-paragraph=\"\"><b>BLS signature scheme<\/b><\/p><p id=\"a0e5\" class=\"gk gl dn gm b gn io gp gq gr ip gt gu gv iq gx gy gz ir hb hc hd is hf hg hh dg ch\" data-selectable-paragraph=\"\">Now we have everything we need to construct a BLS signature. As usual our private key is some secret number <strong class=\"gm hr\"><em class=\"hs\">pk<\/em><\/strong>, our public key is <strong class=\"gm hr\"><em class=\"hs\">P = pk\u00d7G<\/em><\/strong> and the message we are signing is <strong class=\"gm hr\"><em class=\"hs\">m<\/em><\/strong>.<\/p><p id=\"5ba2\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">To calculate the signature we hash our message to the curve <strong class=\"gm hr\"><em class=\"hs\">H(m)<\/em><\/strong> and multiply resulting point by our private key: <strong class=\"gm hr\"><em class=\"hs\">S = pk\u00d7H(m)<\/em><\/strong>. That\u2019s it! Nothing else \u2014 no random numbers, no extra operations, just a hash times the private key! Our signature is just one single point on the curve that takes only 33 bytes in compressed serialisation format!<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-f7cf086 elementor-widget elementor-widget-image\" data-id=\"f7cf086\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"793\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-IpmIdJLR36iHnOHq1OqHnw@2x-1024x793.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-IpmIdJLR36iHnOHq1OqHnw@2x-1024x793.png 1024w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-IpmIdJLR36iHnOHq1OqHnw@2x-300x232.png 300w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-IpmIdJLR36iHnOHq1OqHnw@2x-768x595.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-IpmIdJLR36iHnOHq1OqHnw@2x-600x465.png 600w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-IpmIdJLR36iHnOHq1OqHnw@2x.png 1355w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">BLS signature generation. To obtain signature we multiply a hash of the message by the private key.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-9d453e4 elementor-widget elementor-widget-text-editor\" data-id=\"9d453e4\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p id=\"ec61\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">To verify this signature one can take our public key <strong class=\"gm hr\"><em class=\"hs\">P<\/em><\/strong> and check that<\/p><p id=\"1881\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\"><strong class=\"gm hr\"><em class=\"hs\">e(P, H(m)) = e(G, S)<\/em><\/strong><\/p><p id=\"7627\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">It it true because of the nice property of the pairing function described above:<\/p><p id=\"4247\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\"><strong class=\"gm hr\"><em class=\"hs\">e(P, H(m)) = e(pk\u00d7G, H(m)) = e(G, pk\u00d7H(m)) = e(G, S)<\/em><\/strong><\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-641b5aa elementor-widget elementor-widget-image\" data-id=\"641b5aa\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"1022\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x-1024x1022.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x-1024x1022.png 1024w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x-150x150.png 150w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x-300x300.png 300w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x-768x767.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x-600x599.png 600w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x-100x100.png 100w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-CyqBtsUTnME5R4QTU_ZZCg@2x.png 1337w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">BLS signature verification. We just need to check that the public key and the message hash are mapped to the same number as the curve generator point and the signature.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-f55cc82 elementor-widget elementor-widget-text-editor\" data-id=\"f55cc82\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p>This signature scheme is beautiful and simple, but it also has several very nice features, especially for Bitcoin.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Signature aggregation<\/b><\/h3><p data-selectable-paragraph=\"\">Now let\u2019s combine all signatures in the block! Imagine we have a block with 1000 transactions and every transaction contains a signature <strong><em>Si<\/em><\/strong>, a public key <strong><em>Pi<\/em><\/strong> and a message that is signed <strong><em>mi<\/em><\/strong>. Why to store all the signatures if we can combine them? After all, we only care if all signatures in the block are valid. Aggregated signature will be just a sum of all signatures in the block:<\/p><p data-selectable-paragraph=\"\"><strong><em>S = S1+S2+\u2026+S1000<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">To verify the block we need to check that the following equality holds:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(G, S) = e(P1, H(m1))\u22c5e(P2, H(m2))\u22c5\u2026\u22c5e(P1000, H(m1000))<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">If you look carefully you will see that it\u2019s indeed true:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(G, S) = e(G, S1+S2+\u2026+S1000) = e(G, S1)\u22c5e(G, S2)\u22c5\u2026\u22c5e(G, S1000) = e(G, pk1\u00d7H(m1))\u22c5\u2026\u22c5e(G, pk1000\u00d7H(m1000)) = e(pk1\u00d7G, H(m1))\u22c5\u2026\u22c5e(pk1000\u00d7G, H(m1000)) = e(P1, H(m1))\u22c5e(P2, H(m2))\u22c5\u2026\u22c5e(P1000, H(m1000))<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">We still need to know all the public keys and calculate 1001 pairing functions, but at least <em>all the signatures in the block take only 33 bytes<\/em>. Signature aggregation can be done by a miner and save a lot of space in the block.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Key aggregation and n-of-n multisignature<\/b><\/h3><p data-selectable-paragraph=\"\">If we are using multisignature addresses, we are signing <em>the same transaction<\/em> with different keys. In this case we can do key aggregation like in Schnorr, where we combine all signatures and all keys to a single pair of a key and a signature. Let\u2019s take a common 3-of-3 multisig scheme (it can be done similarly for any number of signers).<\/p><p data-selectable-paragraph=\"\">A simple way to combine them is to add all the signatures and all the keys together. The result will be a signature <strong><em>S=S1+S2+S3<\/em><\/strong> and a key <strong><em>P=P1+P2+P3<\/em><\/strong>. It\u2019s easy to see that the same verification equation still works:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(G, S) = e(P, H(m))<\/em><\/strong><\/p><p data-selectable-paragraph=\"\"><strong><em>e(G, S) = e(G, S1+S2+S3) = e(G, (pk1+pk2+pk3)\u00d7H(m)) = e((pk1+pk2+pk3)\u00d7G, H(m)) = e(P1+P2+P3, H(m)) = e(P, H(m))<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">Just like in Schnorr we need to protect ourselves from the rogue key attack. We can do it either by asking every co-signer to prove that they have private keys for their public keys (by signing their public keys), or we can add some nonlinearity to the scheme and make rogue key attack impossible. Instead of just summing up all the keys and signatures we multiply them by a certain number and then add:<\/p><p data-selectable-paragraph=\"\"><strong><em>S = a1\u00d7S1+a2\u00d7S2+a3\u00d7S3<\/em><\/strong><\/p><p data-selectable-paragraph=\"\"><strong><em>P = a1\u00d7P1+a2\u00d7P2+a3\u00d7P3<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">Here coefficients of the signatures and keys are calculated deterministically from the public key of the signer and all other public keys:<\/p><p data-selectable-paragraph=\"\"><strong><em>ai = hash(Pi, {P1,P2,P3})<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">For example it can be just a concatenation of the signer\u2019s public key and the whole set of public keys used for signing: <strong><em>ai = hash(Pi||P1||P2||P3)<\/em><\/strong>.<\/p><p data-selectable-paragraph=\"\">The same verification equation still works. There will be additional coefficients <strong><em>ai<\/em><\/strong> in the proof, but the logic remains.<\/p><p data-selectable-paragraph=\"\">Nice thing about this scheme is that you don\u2019t need several communication rounds between devices. You just need to know who are other signers, and you are all set. This is much simpler than 3-round multisig scheme for Schnorr signatures. It also doesn\u2019t rely on any randomness, it is a <em>completely deterministic signature algorithm<\/em>.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Subgroup multisignature scheme (m-of-n multisig)<\/b><\/h3><p data-selectable-paragraph=\"\">Often we don\u2019t want to use n-of-n multisig scheme, we prefer to use m-of-n, say, 2-of-3. We don\u2019t want to lose all our money just because we\u2019ve lost one of our keys. It would be nice to use key aggregation in this scenario. With Schnorr signatures we were able to do so by using merkle tree of public keys. It is not the most efficient way, but it kinda works. Unfortunately, as soon as you go to high <strong><em>m<\/em><\/strong> and <strong><em>n<\/em><\/strong> values, merkle tree size blows up exponentially.<\/p><p data-selectable-paragraph=\"\">With BLS signature scheme there is another method. It\u2019s not that simple though. We will need a normal hash function that outputs a number \u2014 <strong><em>hash(x)<\/em><\/strong>, and a hash to the curve \u2014 <strong><em>H(x)<\/em><\/strong>. We will also need a \u201csetup\u201d phase when we decide to use multisig, but after this we don\u2019t need to communicate anymore \u2014 we only need signatures to sign any amount of transactions.<\/p><p data-selectable-paragraph=\"\">Again I will use a simple example where we want to construct 2-of-3 multisig scheme with keys stored on 3 different devices, but it can be extended to any values of <strong><em>m<\/em><\/strong> and <strong><em>n<\/em><\/strong>.<\/p><p data-selectable-paragraph=\"\"><b>Setup phase<\/b><\/p><p data-selectable-paragraph=\"\">Each of our devices has a signer\u2019s number <strong><em>i = 1,2,3 <\/em><\/strong>that represent its place in a set, a private key <strong><em>pki <\/em><\/strong>and a corresponding public key <strong><em>Pi = pki\u00d7G<\/em><\/strong>. We calculate an aggregated public key exactly the same way as before:<\/p><p data-selectable-paragraph=\"\"><strong><em>P = a1\u00d7P1+a2\u00d7P2+a3\u00d7P3, ai = hash(Pi, {P1,P2,P3})<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">Now every device needs to sign that number <strong><em>i<\/em><\/strong> is a member of our aggregated public key (for every <strong><em>i<\/em><\/strong>), aggregate these signatures and save the result on corresponding device:<\/p><p data-selectable-paragraph=\"\"><strong><em>MKi = (a1\u22c5pk1)\u00d7H(P, i)+(a2\u22c5pk2)\u00d7H(P, i)+(a3\u22c5pk3)\u00d7H(P, i)<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">This signature we will call a \u201cmembership key\u201d and we will use it later on for signing. Each membership key is a valid n-of-n signature of the message <strong><em>H(P,i)<\/em><\/strong>, it means that:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(G, MKi)=e(P, H(P,i))<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">Remember this equation, we will need it later. It will be used to prove that we are valid participants of the multisignature scheme.<\/p><p data-selectable-paragraph=\"\"><b>Signing<\/b><\/p><p data-selectable-paragraph=\"\">Now let\u2019s say we want to sign a transaction only with keys <strong><em>pk1<\/em><\/strong> and <strong><em>pk3<\/em><\/strong>. We generate two signatures <strong><em>S1<\/em><\/strong> and <strong><em>S3<\/em><\/strong><em>:<\/em><\/p><p data-selectable-paragraph=\"\"><strong><em>S1 = pk1\u00d7H(P, m)+MK1<\/em><\/strong>, <strong><em>S3=pk3\u00d7H(P, m)+MK3<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">and add them up to obtain single signature and key:<\/p><p data-selectable-paragraph=\"\"><strong><em>(S\u2019, P\u2019) = (S1+S3, P1+P3)<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">I write <strong><em>P\u2019<\/em><\/strong> and <strong><em>S\u2019<\/em><\/strong> here to emphasise that this key and signature are signed only by <em>a subset <\/em>of signers and it not the same as <strong><em>P<\/em><\/strong> that is an aggregated key for <em>all signers<\/em>. To verify this 2-of-3 signature we need to check that:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(G, S\u2019) = e(P\u2019, H(P, m))\u22c5e(P, H(P, 1)+H(P, 3))<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">We remember that membership keys <strong><em>MK1<\/em><\/strong> and <strong><em>MK3<\/em><\/strong> are valid signatures for messages <strong><em>H(P, 1)<\/em><\/strong> and <strong><em>H(P, 3)<\/em><\/strong> signed by aggregated key <strong><em>P<\/em><\/strong>, so:<\/p><p data-selectable-paragraph=\"\"><strong><em>e(G, S\u2019) = e(G, S1+S3)=e(G, pk1\u00d7H(P, m)+pk3\u00d7H(P, m)+MK1+MK3) =e(G, pk1\u00d7H(P, m)+pk3\u00d7H(P, m))\u22c5e(G, MK1+MK3)=e(pk1\u00d7G+pk3\u00d7G, H(P, m))\u22c5e(P, H(P, 1)+H(P, 3))=e(P\u2019, H(P, m))\u22c5e(P, H(P, 1)+H(P, 3))<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">That\u2019s it. A bit more complicated than n-of-n, but still understandable.<\/p><p data-selectable-paragraph=\"\"><b>Possible implementation<\/b><\/p><p data-selectable-paragraph=\"\">To implement this multisignature scheme we will need to send money to an address corresponding to an aggregated public key <strong><em>P<\/em><\/strong> and say that we need at least two signatures. In Bitcoin scripting language locking script could look like this:<\/p><p data-selectable-paragraph=\"\"><strong><em>OP_2 &lt;P&gt; OP_CHECK_BLS_MULTISIG<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">Here <strong><em>OP_2<\/em><\/strong> tells that we require two keys to sign the message. We don\u2019t say anywhere that there are 3 signers in total, so one can\u2019t say if it is 2-of-3 or 2-of-100 multisig address. We also don\u2019t reveal this information later.<\/p><p data-selectable-paragraph=\"\">To spend this output we need to provide a key <strong><em>P\u2019<\/em><\/strong>, signature <strong><em>S\u2019<\/em><\/strong> and indexes of participating signers \u2014 in our case numbers 1 and 3. Unlocking script could look like this:<\/p><p data-selectable-paragraph=\"\"><strong><em>OP_1 OP_3 &lt;P\u2019&gt; &lt;S\u2019&gt;<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">Combining these scripts gives us all necessary information. From <strong><em>OP_1<\/em><\/strong> and <strong><em>OP_3<\/em><\/strong> we know that we need to calculate hashes <strong><em>H(P, 1)<\/em><\/strong> and <strong><em>H(P, 3)<\/em><\/strong>, and then we have everything we need to verify the transaction.<\/p><p data-selectable-paragraph=\"\">This means that for <em>any <\/em><strong><em>m<\/em><\/strong><em> and <\/em><strong><em>n<\/em><\/strong> we need only:<\/p><ul><li data-selectable-paragraph=\"\">one aggregated public key <strong><em>P<\/em><\/strong> in the locking script<\/li><li data-selectable-paragraph=\"\">one aggregated public key of participating signers <strong><em>P\u2019<\/em><\/strong><\/li><li data-selectable-paragraph=\"\">one aggregated signature <strong><em>S\u2019<\/em><\/strong><\/li><li data-selectable-paragraph=\"\"><strong><em>m<\/em><\/strong> numbers with signer\u2019s indexes.<\/li><\/ul><p data-selectable-paragraph=\"\">It is very compact and beautiful!<\/p><p data-selectable-paragraph=\"\">There is only one thing that I don\u2019t like here\u2026 Normally we use addresses only once \u2014 we use key derivation like BIP32 to generate new private keys and addresses. But for every new set of private keys we also need a set of new membership keys. One way to do it without running through setup phase every time is to generate a bunch of keys, like 1000 of them and get corresponding membership keys. After all, they are just 32-byte long. Then we will need to run the setup phase again only when all 1000 addresses are used.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Drawbacks<\/b><\/h3><p data-selectable-paragraph=\"\">As it was pointed out in the comments here and on twitter, I skipped one important part and made you think that BLS signatures are perfect. They are not. And thanks a lot for bringing this up!<\/p><p data-selectable-paragraph=\"\"><em>Pairing is hard<\/em>. I completely skipped that part and we considered that our magic function <strong><em>e(P, Q)<\/em><\/strong> is efficient and secure. It is not exactly true.<\/p><p data-selectable-paragraph=\"\"><b>Paring is not so efficient<\/b><\/p><p data-selectable-paragraph=\"\">BLS signature verification is order of magnitude harder than ECDSA. Signature aggregation for the whole block with 1000 transactions still requires to compute 1000 pairing, so verifying one tiny signature in a block may take longer than verifying 1000 separate ECDSA signatures. The only benefit we achieve here is that we can fit more transactions in the block as aggregated signature takes only ~32 bytes.<\/p><p data-selectable-paragraph=\"\">Unlike BLS, Schnorr signatures are very efficient \u2014 they can be validated all together and this process is factor of 3 more efficient than ECDSA. The question then arises: what is more important for us?<\/p><p data-selectable-paragraph=\"\"><b>Security proof is harder<\/b><\/p><p data-selectable-paragraph=\"\">Pairing functions are complicated, and it can become our foe if we are not careful enough. On the one hand we want pairing to be efficient to verify signatures faster, on the other hand we don\u2019t want to reveal any information about our secret key. These two requirements fight each other and we need to be extremely careful with our choice of pairing-friendly curves.<\/p><p data-selectable-paragraph=\"\">There is actually an attack on elliptic curve crypto systems, called <a href=\"https:\/\/sci-hub.tw\/https:\/\/ieeexplore.ieee.org\/document\/259647\/\" target=\"_blank\" rel=\"noopener nofollow\">MOV attack<\/a> (named after Menezes, Okamoto, and Vanstone), that allows to reduce security of the system by using our magic pairing function. So we really need to be careful here.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Conclusion<\/b><\/h3><p data-selectable-paragraph=\"\">BLS signatures are amazing \u2014 we can combine all signatures in a block to a single signature, we can use key aggregation and m-of-n multisig scheme without additional communication rounds, we don\u2019t need to rely on random number generators and the scheme itself looks very nice and simple. There is still room for improvement, standardising and optimising everything will take some time. But I hope at some point this signature algorithm will become good enough to be included in the Bitcoin protocol and we will be able to use all these nice features with smaller and more aggregatable signatures.<\/p><p data-selectable-paragraph=\"\">I am very excited to see the first author Dan Boneh working on cryptocurrencies. He is a great cryptographer and his <a href=\"https:\/\/www.coursera.org\/learn\/crypto\" target=\"_blank\" rel=\"noopener nofollow\">coursera crypto course<\/a> is outstanding. I also recommend his <a href=\"http:\/\/toc.cryptobook.us\/\" target=\"_blank\" rel=\"noopener nofollow\">crypto book<\/a> even though it\u2019s not finished yet. I am sure we will see many interesting schemes and protocol improvements from him and his team in the near future.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t<\/div>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t<\/section>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t","protected":false},"excerpt":{"rendered":"<p>In the previous post I wrote about Schnorr signatures and how awesome they are. This one is about Boneh-Lynn-Shacham signatures and their extremely nice features that are not possible with Schnorr. Shortly, what we know so far: ECDSA signatures are ok. They do their job and do it well, but nothing more. We can\u2019t combine &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"https:\/\/specter.solutions\/bls-signatures-better-than-schnorr\/\"> <span class=\"screen-reader-text\">BLS signatures: better than Schnorr<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":6,"featured_media":3677,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false,"site-sidebar-layout":"default","site-content-layout":"default","ast-main-header-display":"","ast-hfb-above-header-display":"","ast-hfb-below-header-display":"","ast-hfb-mobile-header-display":"","site-post-title":"","ast-breadcrumbs-content":"","ast-featured-img":"","footer-sml-layout":"","theme-transparent-header-meta":"default","adv-header-id-meta":"","stick-header-meta":"","header-above-stick-meta":"","header-main-stick-meta":"","header-below-stick-meta":"","footnotes":""},"categories":[30,38,40,39],"tags":[],"_links":{"self":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3671"}],"collection":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/users\/6"}],"replies":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/comments?post=3671"}],"version-history":[{"count":12,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3671\/revisions"}],"predecessor-version":[{"id":4530,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3671\/revisions\/4530"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/media\/3677"}],"wp:attachment":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/media?parent=3671"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/categories?post=3671"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/tags?post=3671"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}