{"id":3703,"date":"2018-06-23T22:09:26","date_gmt":"2018-06-23T22:09:26","guid":{"rendered":"https:\/\/specter.solutions\/?p=3703"},"modified":"2021-10-19T09:55:16","modified_gmt":"2021-10-19T09:55:16","slug":"how-schnorr-signatures-may-improve-bitcoin","status":"publish","type":"post","link":"https:\/\/specter.solutions\/how-schnorr-signatures-may-improve-bitcoin\/","title":{"rendered":"How Schnorr signatures may improve Bitcoin"},"content":{"rendered":"\t\t<div data-elementor-type=\"wp-post\" data-elementor-id=\"3703\" class=\"elementor elementor-3703\">\n\t\t\t\t\t\t<div class=\"elementor-inner\">\n\t\t\t\t<div class=\"elementor-section-wrap\">\n\t\t\t\t\t\t\t\t\t<section class=\"elementor-section elementor-top-section elementor-element elementor-element-3f79218 elementor-section-boxed elementor-section-height-default elementor-section-height-default\" data-id=\"3f79218\" data-element_type=\"section\">\n\t\t\t\t\t\t<div class=\"elementor-container elementor-column-gap-default\">\n\t\t\t\t\t\t\t<div class=\"elementor-row\">\n\t\t\t\t\t<div class=\"elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-115b6f5\" data-id=\"115b6f5\" data-element_type=\"column\">\n\t\t\t<div class=\"elementor-column-wrap elementor-element-populated\">\n\t\t\t\t\t\t\t<div class=\"elementor-widget-wrap\">\n\t\t\t\t\t\t<div class=\"elementor-element elementor-element-0c072e9 elementor-widget elementor-widget-text-editor\" data-id=\"0c072e9\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p data-selectable-paragraph=\"\">When I was reading the <a href=\"https:\/\/eprint.iacr.org\/2018\/068.pdf\" target=\"_blank\" rel=\"noopener nofollow\">MuSig<\/a> paper from Blockstream I was trying to imagine what would it mean for me as a bitcoin user. Some features of the Schnorr signatures I found really great and convenient, but others are pretty annoying. Here I want to share my thoughts with you, but first, a quick recap:<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Elliptic Curve Digital Signature Algorithm<\/b><\/h3><p data-selectable-paragraph=\"\">Currently in Bitcoin we use <a href=\"https:\/\/en.wikipedia.org\/wiki\/Elliptic_Curve_Digital_Signature_Algorithm\" target=\"_blank\" rel=\"noopener nofollow\">ECDSA<\/a>. To sign a message <strong><em>m<\/em><\/strong> we hash it and treat this hash as a number: <strong><em>z = hash(m)<\/em><\/strong>. We also need a random or random-looking number <strong><em>k<\/em><\/strong>. We prefer not to trust random number generators (too many failures and vulnerabilities are related to bad RGNs) so we usually use <a href=\"https:\/\/tools.ietf.org\/html\/rfc6979\" target=\"_blank\" rel=\"noopener nofollow\">RFC6979<\/a> to calculate <strong><em>deterministic k<\/em><\/strong> based on our secret and the message we are signing.<\/p><p data-selectable-paragraph=\"\">Using a private key <strong><em>pk<\/em><\/strong> we can generate a signature for message <strong><em>m<\/em><\/strong> consisting of two numbers: <strong><em>r<\/em><\/strong> (<strong><em>x<\/em><\/strong> coordinate of the random point <strong><em>R = k\u00d7G<\/em><\/strong>) and <strong><em>s = (z+r\u22c5pk)\/k<\/em><\/strong>. Then, using our public key <strong><em>P = pk\u00d7G<\/em><\/strong> anyone can verify our signature by checking that point <strong><em>(z\/s)\u00d7G+(r\/s)\u00d7P<\/em><\/strong> has <strong><em>x <\/em><\/strong>coordinate equal to <strong><em>r<\/em><\/strong>.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-510ab4e elementor-widget elementor-widget-image\" data-id=\"510ab4e\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"991\" height=\"1024\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-aWEbhqQIpHXZgvNpRSi54g@2x-991x1024.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-aWEbhqQIpHXZgvNpRSi54g@2x-991x1024.png 991w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-aWEbhqQIpHXZgvNpRSi54g@2x-290x300.png 290w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-aWEbhqQIpHXZgvNpRSi54g@2x-768x793.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-aWEbhqQIpHXZgvNpRSi54g@2x-600x620.png 600w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-aWEbhqQIpHXZgvNpRSi54g@2x.png 1400w\" sizes=\"(max-width: 991px) 100vw, 991px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">Visualisation of the ECDSA algorithm. Elliptic curve is plotted over real numbers for illustration purposes.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-ae98166 elementor-widget elementor-widget-text-editor\" data-id=\"ae98166\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p data-selectable-paragraph=\"\">This algorithm is very common and pretty nice but it can be improved. First, signature verification includes inversion (<strong><em>1\/s<\/em><\/strong>) and two points multiplications and these operations are very computationally heavy. In Bitcoin every node has to verify all the transactions. This means that when you broadcast a transaction, thousands of computers will have to verify your signature. Making verification process simpler will be very beneficial even if signing process is harder.<\/p><p data-selectable-paragraph=\"\">Second, every node has to verify every signature separately. In case of m-of-n multisig transaction node may even have to verify the same signature several times. For example, transaction with 7-of-11 multisig input will contain 7 signatures and require from 7 to 11 signature verifications <em>on every node<\/em> in the network. Also such transaction will take a huge amount of space in the block and you will have to pay large fees for that.<\/p><h3 data-selectable-paragraph=\"\">\u00a0<\/h3><h3 data-selectable-paragraph=\"\"><b>Schnorr signatures<\/b><\/h3><p data-selectable-paragraph=\"\">Schnorr signatures are generated slightly differently. Instead of two scalars <strong><em>(r,s)<\/em><\/strong> we use a point <strong><em>R<\/em><\/strong> and a scalar <strong><em>s<\/em><\/strong>. Similar to ECDSA, <strong><em>R<\/em><\/strong> is a random point on elliptic curve (<strong><em>R = k\u00d7G<\/em><\/strong>). Second part of the signature is calculated slightly differently: <strong><em>s = k + hash(P,R,m) \u22c5 pk<\/em><\/strong>. Here <strong><em>pk<\/em><\/strong> is your private key, <strong><em>P = pk\u00d7G <\/em><\/strong>is your public key, <strong><em>m<\/em><\/strong> is the message. Then one can verify this signature by checking that <strong><em>s\u00d7G = R + hash(P,R,m)\u00d7P<\/em><\/strong>.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-ed9fca2 elementor-widget elementor-widget-image\" data-id=\"ed9fca2\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"956\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-hIjYiOdjwBVqdRpa5lrJOg@2x-1024x956.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-hIjYiOdjwBVqdRpa5lrJOg@2x-1024x956.png 1024w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-hIjYiOdjwBVqdRpa5lrJOg@2x-300x280.png 300w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-hIjYiOdjwBVqdRpa5lrJOg@2x-768x717.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-hIjYiOdjwBVqdRpa5lrJOg@2x-600x560.png 600w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-hIjYiOdjwBVqdRpa5lrJOg@2x.png 1400w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">Visualisation of the Schnorr signature verification.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-7e57c62 elementor-widget elementor-widget-text-editor\" data-id=\"7e57c62\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p id=\"7439\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">This equation is linear, so equations can be added and subtracted with each other and still stay valid. This brings us to several nice features of Schnorr signatures that we can use.<\/p><p id=\"8907\" class=\"jp hk dn au av jq jr js hn jt ju jv hq jw jx jy hu jz ka kb hy kc kd ke ic kf ch\" data-selectable-paragraph=\"\"><b>1. Batch validation<\/b><\/p><p id=\"2bc6\" class=\"gk gl dn gm b gn ie gp gq gr if gt gu gv ig gx gy gz ih hb hc hd ii hf hg hh dg ch\" data-selectable-paragraph=\"\">To verify a block in Bitcoin blockchain we need to make sure that <em class=\"ik\">all<\/em> signatures in the block are valid. If one of them is not valid we don\u2019t care which one \u2014 we just reject the whole block and that\u2019s it.<\/p><p id=\"02ff\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">With ECDSA every signature has to be verified separately. Meaning that if we have 1000 signatures in the block we will need to compute 1000 inversions and 2000 point multiplications. In total ~3000 heavy operations.<\/p><p id=\"7e75\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">With Schnorr signatures we can add up all the signature verification equations and save some computational power. In total for a block with 1000 transactions we need to verify that:<\/p><p id=\"e4c6\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\"><strong class=\"gm ij\"><em class=\"ik\">(s1+s2+\u2026+s1000)\u00d7G=(R1+\u2026+R1000)+(hash(P1,R1,m1)\u00d7P1+ hash(P2,R2,m2)\u00d7P2+\u2026+hash(P1000,R1000,m1000)\u00d7P1000)<\/em><\/strong><\/p><p id=\"3619\" class=\"gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch\" data-selectable-paragraph=\"\">Here we have a bunch of point additions (almost free in sense of computational power) and 1001 point multiplication. This is already a factor of 3 improvement \u2014 we need to compute roughly one heavy operation per signature.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-8e2f49f elementor-widget elementor-widget-image\" data-id=\"8e2f49f\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"364\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-1024x364.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-1024x364.png 1024w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-300x107.png 300w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-768x273.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-1536x546.png 1536w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-2048x728.png 2048w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-600x213.png 600w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">Batch validation of two signatures. As verification equation is linear the sum of several equations is valid as soon as all signatures are valid. We save some computational power as scalar and point additions are much easier than point multiplication.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-7d20e8b elementor-widget elementor-widget-text-editor\" data-id=\"7d20e8b\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<p data-selectable-paragraph=\"\"><b>2. Key aggregation<\/b><\/p><p data-selectable-paragraph=\"\">We want to keep our bitcoins safe, so we might want to use at least two different private keys to control bitcoins. One we will use on a laptop or a phone and another one \u2014 on a hardware wallet \/ cold wallet. So when one of them is compromised we still have control over our bitcoins.<\/p><p data-selectable-paragraph=\"\">Currently it is implemented via 2-of-2 multisig script. This requires two separate signatures to be included in the transaction.<\/p><p data-selectable-paragraph=\"\">With Schnorr signatures we can use a pair of private keys <strong><em>(pk1,pk2)<\/em><\/strong> and generate a shared signature corresponding to a shared public key <strong><em>P=P1+P2=pk1\u00d7G+pk2\u00d7G<\/em><\/strong>. To generate this signature we need to choose a random number on every device <strong><em>(k1,k2)<\/em><\/strong>, generate a random point <strong><em>Ri=ki\u00d7G<\/em><\/strong>, add them up to calculate a common <strong><em>hash(P,R1+R2,m)<\/em><\/strong> and then get <strong><em>s1<\/em><\/strong> and <strong><em>s2<\/em><\/strong> from every device (<strong><em>si = ki + hash(P,R,m) \u22c5 pki<\/em><\/strong>). Then we can add up these signatures and use a pair <strong><em>(R, s) = (R1+R2, s1+s2)<\/em><\/strong> as our signature for shared public key <strong><em>P<\/em><\/strong>. Everyone else won\u2019t be able to say if it is an aggregated signature or not \u2014 it looks exactly the same as a normal Schnorr signature.<\/p><p data-selectable-paragraph=\"\">There are three problems with this construction. First one \u2014 from UI point of view. To make a transaction we need several communication rounds \u2014 to calculate common <strong><em>R<\/em><\/strong>, and then \u2014 to sign. With two private keys it can be done with a single access to the cold wallet: we prepare an unsigned transaction on our online wallet, choose <strong><em>k1<\/em><\/strong> and write down <strong><em>R1=k1\u00d7G <\/em><\/strong>together with the unsigned transaction. Then we transfer this data to the cold wallet and sign. As we already have <strong><em>R1<\/em><\/strong> we can sign transaction on the cold wallet in one run. From the cold wallet we get <strong><em>R2 <\/em><\/strong>and <strong><em>s2<\/em><\/strong> which we transfer back to the online wallet. Online wallet signs the transaction with previously chosen <strong><em>(k1, R1)<\/em><\/strong>, combines both signatures and broadcasts a signed transaction. This is pretty much similar to what we have now, but as soon as you add a third private key everything becomes more complicated. Imagine you have a fortune that is controlled by 10 private keys stored in different secure places around the world and you need to make a transaction. Currently you need to go over all these places only once, but if you are using key aggregation you need to do it twice \u2014 to assemble all <strong><em>Ri<\/em><\/strong> and then to sign. In this case it would probably be better to stay with separate signatures without aggregation \u2014 then only one round is necessary.<\/p><p data-selectable-paragraph=\"\"><em>Post update, thanks to Manu Drijvers for bringing this up<\/em>:<em> for a provably secure multisignature scheme you need 3 communication rounds:<\/em><\/p><ul><li data-selectable-paragraph=\"\"><em>Choose a random number <\/em><strong><em>ki<\/em><\/strong><em> and corresponding <\/em><strong><em>Ri=ki\u00d7G<\/em><\/strong><em> and tell everyone only it\u2019s hash <\/em><strong><em>ti=hash(Ri)<\/em><\/strong><em>, so that everyone can be sure that you will not change your mind after learning other\u2019s random numbers,<\/em><\/li><li data-selectable-paragraph=\"\"><em>Gather all the numbers <\/em><strong><em>Ri<\/em><\/strong><em> together and calculate common <\/em><strong><em>R<\/em><\/strong><\/li><li data-selectable-paragraph=\"\"><em>Sign<\/em><\/li><\/ul><p data-selectable-paragraph=\"\">Second problem is a known Rogue key attack. It is nicely described in the paper or <a href=\"https:\/\/bitcointechtalk.com\/scaling-bitcoin-schnorr-signatures-abe3b5c275d1\" target=\"_blank\" rel=\"noopener nofollow\">here<\/a>, so I won\u2019t go into details. The idea is that if one of your devices is hacked (say, your online wallet) and pretends that its public key is <strong><em>(P1-P2)<\/em><\/strong> then it can control shared funds with its private key <strong><em>pk1<\/em><\/strong>. A simple solution is to require a public key to be signed with corresponding private key when we are setting up the devices.<\/p><p data-selectable-paragraph=\"\">And there is a third important problem. <em>You can\u2019t use deterministic k<\/em> <em>for signing<\/em>. There is a simple attack that allows a hacker to get our private key if you are using deterministic <strong><em>k<\/em><\/strong>. Attack looks like this: someone hacked our laptop and has a complete control over one of two private keys (say, <strong><em>pk1<\/em><\/strong>). We feel safe as our bitcoins require an aggregated signature from both <strong><em>pk1<\/em><\/strong> and <strong><em>pk2<\/em><\/strong>. So we are trying to make a transaction as usual, prepare an unsigned transaction and <strong><em>R1<\/em><\/strong> value, transfer them to our hardware wallet and sign there. Then transfer back <strong><em>(R2, s2)<\/em><\/strong> and\u2026 something happened to our online wallet and it fails to sign and broadcast. We try to do it again, but our hacked computer uses another random value this time \u2014 <strong><em>R1&#8242;<\/em><\/strong>. We sign the same transaction with our hardware wallet again and bring values <strong><em>(R2, s2&#8242;)<\/em><\/strong> back to our hacked computer. Ups, we\u2019ve lost all our bitcoins.<\/p><p data-selectable-paragraph=\"\">In this attack hacker gets a pair of valid signatures for the same transaction: <strong><em>(R1, s1, R2, s2)<\/em><\/strong> and <strong><em>(R1&#8242;, s1&#8242;, R2, s2&#8242;)<\/em><\/strong>. Here <strong><em>R2<\/em><\/strong> is the same, but <strong><em>R = R1+R2<\/em><\/strong> and <strong><em>R&#8217;=R1&#8217;+R2<\/em><\/strong> are different. This means that the hacker can calculate our second private key: <strong><em>s2-s2&#8217;=(hash(P,R1+R2,m)-hash(P,R1&#8217;+R2,m))\u22c5pk2<\/em><\/strong> and <strong><em>pk2=(s2-s2&#8242;)\/(hash(P,R1+R2,m)-hash(P,R1&#8217;+R2,m))<\/em><\/strong>. I find this the most inconvenient feature of key aggregation \u2014 we will need to use a good random number generators everywhere to use key aggregation.<\/p><p data-selectable-paragraph=\"\"><b>3. MuSig<\/b><\/p><p data-selectable-paragraph=\"\"><a href=\"https:\/\/blockstream.com\/2018\/01\/23\/musig-key-aggregation-schnorr-signatures.html\" target=\"_blank\" rel=\"noopener nofollow\">MuSig<\/a> solves one of these problem \u2014 it makes rogue key attack impossible. The goal is to aggregate signatures and public keys from several parties\/devices to a single one but without proving that you have a private key corresponding to the public key.<\/p><p data-selectable-paragraph=\"\">The aggregated signature corresponds to the aggregated public key. But instead of just adding up public keys of all co-signers we multiply them to some factor. The aggregated public key will be <strong><em>P=hash(L,P1)\u00d7P1+\u2026+hash(L,Pn)\u00d7Pn<\/em><\/strong>. Here <strong><em>L=hash(P1,\u2026,Pn)<\/em><\/strong> \u2014 a common number depending on all public keys. This nonlinearity prevents attacker from constructing a bad public key like in rogue key attack. Even though the attacker knows exactly what should be his <strong><em>hash(L,Patk)\u00d7Patk<\/em><\/strong>, he can\u2019t derive <strong><em>Patk<\/em><\/strong> from it \u2014 it is the same problem as to derive the private key from the public key.<\/p><p data-selectable-paragraph=\"\">The rest is pretty similar to the previous case. To generate a signature each co-signer choses a random number <strong><em>ki<\/em><\/strong> and shares <strong><em>Ri=ki\u00d7G<\/em><\/strong> with others. Then they add up all these random points to a single <strong><em>R=R1+\u2026+Rn<\/em><\/strong> and generate a signature <strong><em>si = ki + hash(P,R,m) \u22c5 hash(L,Pi) \u22c5 pki<\/em><\/strong>. The aggregated signature is <strong><em>(R, s)=(R1+\u2026+Rn, s1+\u2026+sn)<\/em><\/strong> and verification equation is the same as before: <strong><em>s\u00d7G = R + hash(P,R,m)\u00d7P<\/em><\/strong>.<\/p><p data-selectable-paragraph=\"\"><b>4. Merkle Multisig<\/b><\/p><p data-selectable-paragraph=\"\">As you may have noticed, MuSig and key aggregation require <em>all signers to sign a transaction<\/em>. But what if you want to make a 2-of-3 multisig? Is it possible at all to use signature aggregation in this case, or we will have to use our usual OP_CHECKMULTISIG and separate signatures?<\/p><p data-selectable-paragraph=\"\">Well, it is possible, but with a small change in the protocol. We can develop a new op-code similar to OP_CHECKMULTISIG that checks if aggregated signature corresponds to a particular item in the Merkle tree of public keys.<\/p><p data-selectable-paragraph=\"\">For example, if we use a 2-of-3 multisig with public keys <strong><em>P1<\/em><\/strong>, <strong><em>P2<\/em><\/strong> and <strong><em>P3<\/em><\/strong>, then we need to construct a Merkle tree of aggregated public keys for all combinations we can use: <strong><em>(P1, P2)<\/em><\/strong>, <strong><em>(P2, P3)<\/em><\/strong>, <strong><em>(P1, P3)<\/em><\/strong> and put the root in the locking script. To spend bitcoins we provide a signature and a proof that our public key is in the tree. For 2-of-3 multisig there are only 3 elements in the tree and the proof will consist of two hashes \u2014 the one we want to use and its neighbour. For 7-of-11 multisig there will be already 11!\/7!\/4!=330 possible key combinations and the proof will require 8 elements. In general the number of elements in the proof scales almost linear with the number of keys in multisig (it\u2019s <strong><em>log2(n!\/m!\/(n-m)! <\/em><\/strong>).<\/p><p data-selectable-paragraph=\"\">But with the Merkle tree of public keys we are not limited to m-of-n multisigs. We can make a tree with any public keys we want. For example, if we have a laptop, a phone, a hardware wallet and a recovery seed we can construct a structure that would allow us to spend bitcoins with a laptop and a hardware wallet, a phone and a hardware wallet or just with a recovery seed. This is currently not possible just with OP_CHECKMULTISIG \u2014 only if you construct much more complicated script with branches and stuff.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-c435b58 elementor-widget elementor-widget-image\" data-id=\"c435b58\" data-element_type=\"widget\" data-widget_type=\"image.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-image\">\n\t\t\t\t\t\t\t\t\t<figure class=\"wp-caption\">\n\t\t\t\t\t\t\t\t\t\t<img loading=\"lazy\" decoding=\"async\" width=\"1024\" height=\"425\" src=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-1024x425.png\" class=\"attachment-large size-large\" alt=\"\" srcset=\"https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-1024x425.png 1024w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-300x125.png 300w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-768x319.png 768w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-600x249.png 600w, https:\/\/specter.solutions\/wp-content\/uploads\/2021\/01\/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x.png 1400w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>\t\t\t\t\t\t\t\t\t\t\t<figcaption class=\"widget-image-caption wp-caption-text\">Merkle tree of aggregated public keys. More than just m-of-n multisig.<\/figcaption>\n\t\t\t\t\t\t\t\t\t\t<\/figure>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t<div class=\"elementor-element elementor-element-7ab0a1c elementor-widget elementor-widget-text-editor\" data-id=\"7ab0a1c\" data-element_type=\"widget\" data-widget_type=\"text-editor.default\">\n\t\t\t\t<div class=\"elementor-widget-container\">\n\t\t\t\t\t\t\t\t<div class=\"elementor-text-editor elementor-clearfix\">\n\t\t\t\t<h3 data-selectable-paragraph=\"\"><b>Conclusion<\/b><\/h3><p data-selectable-paragraph=\"\">Schnorr signatures are great. They can save some computational power during block validation and also give us ability to use key aggregation. The last one has some inconveniences, but we aren\u2019t forced to use them \u2014 after all, if we want we can continue using normal multisig schemes with separate, non-aggregated signatures and still gain something. I can\u2019t wait to start using them and I hope they will be included in the Bitcoin protocol soon.<\/p><p data-selectable-paragraph=\"\">I really liked the <a href=\"https:\/\/eprint.iacr.org\/2018\/068.pdf\" target=\"_blank\" rel=\"noopener nofollow\">paper<\/a>, the MuSig scheme is smart and the paper itself is very easy to read. I would strongly recommend to look through it if you have time.<\/p><p data-selectable-paragraph=\"\">P.S. There is also another nice type of signatures \u2014 BLS signatures. They look even better than Schnorr in some sense. If you want to know what BLS signatures are about, take a look at my <a href=\"https:\/\/medium.com\/@snigirev.stepan\/bls-signatures-better-than-schnorr-5a7fe30ea716\" target=\"_blank\" rel=\"noopener\">next post<\/a>.<\/p>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t<\/div>\n\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t<\/section>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t<\/div>\n\t\t\t\t\t<\/div>\n\t\t","protected":false},"excerpt":{"rendered":"<p>When I was reading the MuSig paper from Blockstream I was trying to imagine what would it mean for me as a bitcoin user. Some features of the Schnorr signatures I found really great and convenient, but others are pretty annoying. Here I want to share my thoughts with you, but first, a quick recap: &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"https:\/\/specter.solutions\/how-schnorr-signatures-may-improve-bitcoin\/\"> <span class=\"screen-reader-text\">How Schnorr signatures may improve Bitcoin<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":6,"featured_media":3704,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"inline_featured_image":false,"site-sidebar-layout":"default","site-content-layout":"default","ast-main-header-display":"","ast-hfb-above-header-display":"","ast-hfb-below-header-display":"","ast-hfb-mobile-header-display":"","site-post-title":"","ast-breadcrumbs-content":"","ast-featured-img":"","footer-sml-layout":"","theme-transparent-header-meta":"default","adv-header-id-meta":"","stick-header-meta":"","header-above-stick-meta":"","header-main-stick-meta":"","header-below-stick-meta":"","footnotes":""},"categories":[30,38,40,39],"tags":[],"_links":{"self":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3703"}],"collection":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/users\/6"}],"replies":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/comments?post=3703"}],"version-history":[{"count":11,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3703\/revisions"}],"predecessor-version":[{"id":4531,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/posts\/3703\/revisions\/4531"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/media\/3704"}],"wp:attachment":[{"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/media?parent=3703"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/categories?post=3703"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/specter.solutions\/wp-json\/wp\/v2\/tags?post=3703"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}